
/* 
   Workbook (1.0.0)
   ==

   Copyright 2014 Peter W Moresi

   License: GPLv2

   Portions from formula.js Copyright (c) 2014 Sutoiku, Inc. (see LICENSE file)
   
   Portions from SocialCalc Copyright (C) 2009 Socialtext, Inc. (see LICENSE file)
*/

;(function(root) {

    var fn, // a container for functions used by spreadsheet formula
        error,
        //See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
        MAX_SAFE_INTEGER = (Math.pow(2, 53) - 1),
        MAX_COLS = 16384,   // 14 bits, 2^14
        MAX_ROWS = 1048576, // 20 bits, 2^20

        /*
         The cell index tracks a rows and cols with a single number.
         
         The cell index is a value between 0 and 17179869183.

         The max value is the binary number '1111111111111111111111111111111111'.

         The first 20 bits from left-to-right is the row index; from 0...MAX_ROWS-1.
         
         The remaining 14 bits are the column index; from 0...MAX_COLS-1.

         Unfortunately, since JavaScript doesn't have an unsigned shift left I was
         forced to resort to multiplication which is less efficient but will have
         to do.

         Mapping the row/col efficiently to an array is the key to the money.
        */
        CELLINDEX = function(row, col) { return (Math.floor((row) * MAX_COLS) + (col)); },
        INDEX2ADDR = function(index) { var row = INDEX2ROW(index); return { rowIndex: row, colIndex: index - (row * MAX_COLS) }; },
        INDEX2COL = function(index) { return index - (INDEX2ROW(index) * MAX_COLS); },
        INDEX2ROW = function(index) { return Math.floor(index / MAX_COLS); }

        compiledNumber = 0,
        
        // Date Constants
        d1900 = new Date(1900, 0, 1),
        JulianOffset = 2415019,
        MinutesInHour = 60,
        MinutesInDay = 1440,
        SecondsInMinute = 60,
        SecondsInHour = 3600,
        SecondsInDay = 86400,
        DaysInYear = 365.25,
        MilliSecondsInDay = 86400000,

        // Format Constants
        SeparatorChar = ",",
        DecimalChar = ".",
        DefaultCurrency = "$", // the currency string used if none specified
        AllowedColors = {
            BLACK: "#000000", BLUE: "#0000FF", CYAN: "#00FFFF",
            GREEN: "#00FF00", MAGENTA: "#FF00FF", RED: "#FF0000",
            WHITE: "#FFFFFF", YELLOW: "#FFFF00"},
        AllowedDates = {H: "h]", M: "m]", MM: "mm]", S: "s]", SS: "ss]"},
        DayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        DayNames3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        MonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        MonthNames3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        AM = "AM",
        AM1 = "A",
        PM = "PM",
        PM1 = "P";


    /* parser generated by jison 0.4.15 */
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = (function(){
    var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[1,9],$V5=[1,10],$V6=[1,12],$V7=[1,13],$V8=[1,14],$V9=[1,15],$Va=[1,16],$Vb=[1,17],$Vc=[1,25],$Vd=[1,19],$Ve=[1,20],$Vf=[1,21],$Vg=[1,22],$Vh=[1,23],$Vi=[1,24],$Vj=[1,26],$Vk=[1,27],$Vl=[1,28],$Vm=[1,29],$Vn=[1,30],$Vo=[1,31],$Vp=[5,6,7,8,9,10,11,12,13,14,15,16,17,20,21,33,34,37],$Vq=[5,6,7,8,12,13,14,15,16,17,20,33,34,37],$Vr=[1,62],$Vs=[1,63],$Vt=[20,33,34,37],$Vu=[5,6,7,8,9,10,12,13,14,15,16,17,20,33,34,37],$Vv=[5,6,12,13,14,15,16,20,33,34,37],$Vw=[5,6,12,13,14,15,16,17,20,33,34,37];
    var parser = {trace: function trace() { },
    yy: {},
    symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"=":6,"+":7,"-":8,"*":9,"/":10,"^":11,"<>":12,">":13,"<":14,">=":15,"<=":16,"&":17,"func":18,"(":19,")":20,":":21,"CELL":22,"SHEET":23,"IDENT":24,"array_literal":25,"TRUE":26,"FALSE":27,"STRING":28,"NUMBER":29,"%":30,"range":31,"param_list":32,",":33,";":34,"FUNC":35,"{":36,"}":37,"$accept":0,"$end":1},
    terminals_: {2:"error",5:"EOF",6:"=",7:"+",8:"-",9:"*",10:"/",11:"^",12:"<>",13:">",14:"<",15:">=",16:"<=",17:"&",19:"(",20:")",21:":",22:"CELL",23:"SHEET",24:"IDENT",26:"TRUE",27:"FALSE",28:"STRING",29:"NUMBER",30:"%",33:",",34:";",35:"FUNC",36:"{",37:"}"},
    productions_: [0,[3,2],[3,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,3],[4,3],[4,2],[4,3],[4,3],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[31,3],[32,1],[32,3],[32,3],[18,4],[18,3],[25,3]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
    /* this == yyval */
    
    var $0 = $$.length - 1;
    switch (yystate) {
    case 1: case 2:
     return $$[$0-1]; 
    break;
    case 3:
    this.$ = { type: "operator", subtype: 'infix-add', operands:[$$[$0-2], $$[$0]]}; 
    break;
    case 4:
    this.$ = { type: "operator", subtype: 'infix-subtract', operands:[$$[$0-2], $$[$0]]}; 
    break;
    case 5:
    this.$ = { type: "operator", subtype: 'infix-multiply', operands:[$$[$0-2], $$[$0]]}; 
    break;
    case 6:
    this.$ = { type: "operator", subtype: 'infix-divide', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 7:
    this.$ = { type: "operator", subtype: 'infix-power', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 8:
    this.$ = { type: "operator", subtype: 'infix-ne', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 9:
    this.$ = { type: "operator", subtype: 'infix-eq', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 10:
    this.$ = { type: "operator", subtype: 'infix-gt', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 11:
    this.$ = { type: "operator", subtype: 'infix-lt', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 12:
    this.$ = { type: "operator", subtype: 'infix-gte', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 13:
    this.$ = { type: "operator", subtype: 'infix-lte', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 14:
    this.$ = { type: "operator", subtype: 'prefix-plus', operands:[$$[$0]] }; 
    break;
    case 15: case 16:
    this.$ = { type: "operator", subtype: 'infix-concat', operands:[$$[$0-2], $$[$0]] }; 
    break;
    case 17:
    this.$ = { type: "operator", subtype: 'prefix-minus', operands:[$$[$0]] }; 
    break;
    case 18:
    this.$ = { type: 'group', exp:$$[$0-1] }; 
    break;
    case 19:
    this.$ = { type: 'range', subtype: 'local', topLeft:$$[$0-2], bottomRight:$$[$0] }; 
    break;
    case 20:
    this.$ = { type: 'cell', subtype: 'local', addr:$$[$0] }; 
    break;
    case 21:
     this.$ = { type: 'cell', subtype: 'remote', worksheet: $$[$0-1], addr:$$[$0] }; 
    break;
    case 22:
     this.$ = { type: 'value', subtype: 'variable', value:$$[$0] }; 
    break;
    case 23:
     this.$ = { type: 'cell', subtype: 'remote-named', worksheet: $$[$0-1], addr:$$[$0] }; 
    break;
    case 24: case 25:
     this.$ = $$[$0]; 
    break;
    case 26:
    this.$ = { type: 'value', subtype: 'boolean', value: true }; 
    break;
    case 27:
    this.$ = { type: 'value', subtype: 'boolean', value: false }; 
    break;
    case 28:
    this.$ = { type: 'value', subtype: 'string', value:String(yytext)}; 
    break;
    case 29:
    this.$ = { type: 'value', subtype: 'number', value:$$[$0-1]/100 }; 
    break;
    case 30:
    this.$ = { type: 'value', subtype: 'number', value:Number(yytext) }; 
    break;
    case 32:
     this.$ = [$$[$0]]; 
    break;
    case 33:
     this.$ = $$[$0-2].concat([$$[$0]]); 
    break;
    case 34:
     this.$ = ($$[$0][0].subtype !== 'array') ? [{ type: 'value', subtype: 'array', items:$$[$0-2] }, { type: 'value', subtype: 'array', items:$$[$0] }] : [{ type: 'value', subtype: 'array', items:$$[$0-2] }].concat($$[$0]); 
    break;
    case 35:
     this.$ = { type: 'function', name: $$[$0-3], args:$$[$0-1] }; 
    break;
    case 36:
     this.$ = { type: 'function', name: $$[$0-2], args:[] }; 
    break;
    case 37:
     this.$ = { type: 'value', subtype: 'array', items:$$[$0-1] }; 
    break;
    }
    },
    table: [{3:1,4:2,6:[1,3],7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{1:[3]},{5:[1,18],6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo},{4:32,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:33,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o([5,6,7,8,9,10,11,12,13,14,15,16,20,21,33,34,37],[2,24],{17:[1,34]}),{4:35,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:36,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o($Vp,[2,20]),{22:[1,37],24:[1,38]},o($Vp,[2,22]),o($Vp,[2,25]),o($Vp,[2,26]),o($Vp,[2,27]),o($Vp,[2,28]),o($Vp,[2,30],{30:[1,39]}),{19:[1,40]},{4:42,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:41,35:$Va,36:$Vb},{1:[2,1]},{4:43,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:44,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:45,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:46,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:47,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:48,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:49,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:50,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:51,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:52,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:53,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:54,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:55,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{5:[1,56],6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo},o($Vq,[2,14],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),{4:57,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o($Vp,[2,17]),{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,20:[1,58],21:$Vo},o($Vp,[2,21]),o($Vp,[2,23]),o($Vp,[2,29]),{4:42,7:$V0,8:$V1,18:5,19:$V2,20:[1,60],22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:59,35:$Va,36:$Vb},{33:$Vr,34:$Vs,37:[1,61]},o($Vt,[2,32],{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo}),o($Vq,[2,3],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vq,[2,4],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vu,[2,5],{11:$Vh,21:$Vo}),o($Vu,[2,6],{11:$Vh,21:$Vo}),o([5,6,7,8,9,10,11,12,13,14,15,16,17,20,33,34,37],[2,7],{21:$Vo}),o($Vv,[2,8],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,9],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,10],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,11],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,12],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,13],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vw,[2,15],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vp,[2,19]),{1:[2,2]},o($Vw,[2,16],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vp,[2,18]),{20:[1,64],33:$Vr,34:$Vs},o($Vp,[2,36]),o($Vp,[2,37]),{4:65,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:42,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:66,35:$Va,36:$Vb},o($Vp,[2,35]),o($Vt,[2,33],{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo}),o([20,37],[2,34],{33:$Vr,34:$Vs})],
    defaultActions: {18:[2,1],56:[2,2]},
    parseError: function parseError(str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            throw new Error(str);
        }
    },
    parse: function parse(input) {
        var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                sharedState.yy[k] = this.yy[k];
            }
        }
        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        if (typeof lexer.yylloc == 'undefined') {
            lexer.yylloc = {};
        }
        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;
        if (typeof sharedState.yy.parseError === 'function') {
            this.parseError = sharedState.yy.parseError;
        } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
        }
        _token_stack:
            function lex() {
                var token;
                token = lexer.lex() || EOF;
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
        while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                if (symbol === null || typeof symbol == 'undefined') {
                    symbol = lex();
                }
                action = table[state] && table[state][symbol];
            }
                        if (typeof action === 'undefined' || !action.length || !action[0]) {
                    var errStr = '';
                    expected = [];
                    for (p in table[state]) {
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push('\'' + this.terminals_[p] + '\'');
                        }
                    }
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                    } else {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                    }
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected
                    });
                }
            if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;
            case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                };
                if (ranges) {
                    yyval._$.range = [
                        lstack[lstack.length - (len || 1)].range[0],
                        lstack[lstack.length - 1].range[1]
                    ];
                }
                r = this.performAction.apply(yyval, [
                    yytext,
                    yyleng,
                    yylineno,
                    sharedState.yy,
                    action[1],
                    vstack,
                    lstack
                ].concat(args));
                if (typeof r !== 'undefined') {
                    return r;
                }
                if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
            case 3:
                return true;
            }
        }
        return true;
    }};
    /* generated by jison-lex 0.3.4 */
    var lexer = (function(){
    var lexer = ({
    
    EOF:1,
    
    parseError:function parseError(str, hash) {
            if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
            } else {
                throw new Error(str);
            }
        },
    
    // resets the lexer, sets new input
    setInput:function (input, yy) {
            this.yy = yy || this.yy || {};
            this._input = input;
            this._more = this._backtrack = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = '';
            this.conditionStack = ['INITIAL'];
            this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
            };
            if (this.options.ranges) {
                this.yylloc.range = [0,0];
            }
            this.offset = 0;
            return this;
        },
    
    // consumes and returns one char from the input
    input:function () {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
            } else {
                this.yylloc.last_column++;
            }
            if (this.options.ranges) {
                this.yylloc.range[1]++;
            }
    
            this._input = this._input.slice(1);
            return ch;
        },
    
    // unshifts one char (or a string) into the input
    unput:function (ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
    
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            //this.yyleng -= len;
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
    
            if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
            }
            var r = this.yylloc.range;
    
            this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ?
                    (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                     + oldLines[oldLines.length - lines.length].length - lines[0].length :
                  this.yylloc.first_column - len
            };
    
            if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
            }
            this.yyleng = this.yytext.length;
            return this;
        },
    
    // When called from action, caches matched text and appends it on next action
    more:function () {
            this._more = true;
            return this;
        },
    
    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject:function () {
            if (this.options.backtrack_lexer) {
                this._backtrack = true;
            } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
    
            }
            return this;
        },
    
    // retain first n characters of the match
    less:function (n) {
            this.unput(this.match.slice(n));
        },
    
    // displays already matched input, i.e. for error messages
    pastInput:function () {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
        },
    
    // displays upcoming input, i.e. for error messages
    upcomingInput:function () {
            var next = this.match;
            if (next.length < 20) {
                next += this._input.substr(0, 20-next.length);
            }
            return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
    
    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition:function () {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
        },
    
    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match:function (match, indexed_rule) {
            var token,
                lines,
                backup;
    
            if (this.options.backtrack_lexer) {
                // save context
                backup = {
                    yylineno: this.yylineno,
                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                };
                if (this.options.ranges) {
                    backup.yylloc.range = this.yylloc.range.slice(0);
                }
            }
    
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) {
                this.yylineno += lines.length;
            }
            this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ?
                             lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                             this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) {
                this.done = false;
            }
            if (token) {
                return token;
            } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                    this[k] = backup[k];
                }
                return false; // rule action called reject() implying the next rule should be tested instead.
            }
            return false;
        },
    
    // return next match in input
    next:function () {
            if (this.done) {
                return this.EOF;
            }
            if (!this._input) {
                this.done = true;
            }
    
            var token,
                match,
                tempMatch,
                index;
            if (!this._more) {
                this.yytext = '';
                this.match = '';
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;
                    if (this.options.backtrack_lexer) {
                        token = this.test_match(tempMatch, rules[i]);
                        if (token !== false) {
                            return token;
                        } else if (this._backtrack) {
                            match = false;
                            continue; // rule action called reject() implying a rule MISmatch.
                        } else {
                            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                            return false;
                        }
                    } else if (!this.options.flex) {
                        break;
                    }
                }
            }
            if (match) {
                token = this.test_match(match, rules[index]);
                if (token !== false) {
                    return token;
                }
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
            }
            if (this._input === "") {
                return this.EOF;
            } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
            }
        },
    
    // return next match that has a token
    lex:function lex() {
            var r = this.next();
            if (r) {
                return r;
            } else {
                return this.lex();
            }
        },
    
    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin:function begin(condition) {
            this.conditionStack.push(condition);
        },
    
    // pop the previously active lexer condition state off the condition stack
    popState:function popState() {
            var n = this.conditionStack.length - 1;
            if (n > 0) {
                return this.conditionStack.pop();
            } else {
                return this.conditionStack[0];
            }
        },
    
    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules:function _currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            } else {
                return this.conditions["INITIAL"].rules;
            }
        },
    
    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState:function topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);
            if (n >= 0) {
                return this.conditionStack[n];
            } else {
                return "INITIAL";
            }
        },
    
    // alias for begin(condition)
    pushState:function pushState(condition) {
            this.begin(condition);
        },
    
    // return the number of states currently on the stack
    stateStackSize:function stateStackSize() {
            return this.conditionStack.length;
        },
    options: {},
    performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
    var YYSTATE=YY_START;
    switch($avoiding_name_collisions) {
    case 0:/* skip whitespace */
    break;
    case 1:return 29
    break;
    case 2:return 26
    break;
    case 3:return 27
    break;
    case 4:return 9
    break;
    case 5:return 10
    break;
    case 6:return 8
    break;
    case 7:return 7
    break;
    case 8:return 17
    break;
    case 9:return 11
    break;
    case 10:return 19
    break;
    case 11:return 20
    break;
    case 12:return ">="
    break;
    case 13:return "<="
    break;
    case 14:return "<>"
    break;
    case 15:return "="
    break;
    case 16:return ">"
    break;
    case 17:return "<"
    break;
    case 18:return "{"
    break;
    case 19:return "}"
    break;
    case 20:return "!"
    break;
    case 21:return ","
    break;
    case 22:return ":"
    break;
    case 23:return ";"
    break;
    case 24:return "%"
    break;
    case 25:return 35;
    break;
    case 26:return 35;
    break;
    case 27:yy_.yytext = yy_.yytext.substr(2,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
    break;
    case 28:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
    break;
    case 29:yy_.yytext = yy_.yytext.slice(0, -1); return "SHEET"
    break;
    case 30:yy_.yytext = yy_.yytext.slice(1, -1); return "SHEET"
    break;
    case 31:return "CELL";
    break;
    case 32:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\"\"/g, "\""); return "STRING";
    break;
    case 33:return 24
    break;
    case 34:return 5
    break;
    case 35:return 'INVALID'
    break;
    }
    },
    rules: [/^(?:\s+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:TRUE\b)/,/^(?:FALSE\b)/,/^(?:\*)/,/^(?:\/)/,/^(?:-)/,/^(?:\+)/,/^(?:&)/,/^(?:\^)/,/^(?:\()/,/^(?:\))/,/^(?:>=)/,/^(?:<=)/,/^(?:<>)/,/^(?:=)/,/^(?:>)/,/^(?:<)/,/^(?:\{)/,/^(?:\})/,/^(?:!)/,/^(?:,)/,/^(?::)/,/^(?:;)/,/^(?:%)/,/^(?:[A-Za-z](?=[(]))/,/^(?:[A-Za-z][A-Za-z0-9\.]+(?=[(]))/,/^(?:\$'(?:''|[^'])*'!)/,/^(?:'(?:''|[^'])*'!)/,/^(?:[a-zA-Z]([a-zA-Z0-9.$]+)?!)/,/^(?:\$([a-zA-Z])([a-zA-Z0-9.$]+)?!)/,/^(?:\$?([a-zA-Z]+)\$?([0-9]+))/,/^(?:"(?:""|[^"])*")/,/^(?:[a-zA-Z]([a-zA-Z0-9.$^\(]+)?)/,/^(?:$)/,/^(?:.)/],
    conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true}}
    });
    return lexer;
    })();
    parser.lexer = lexer;
    function Parser () {
      this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser;
    })();

    //////////// FORMULA PARSER ////////////////////////////////////
    if (!parser) { throw Error("Parser is not loaded."); }

    // Calculation Errors
    // Define the error system
    var error = {};
    
    function CalcError(message) {
        this.message = message;
    }
    
    CalcError.prototype = new Error; 
    
    CalcError.prototype.toString = function() {
        return this.message;
    }
    
    error.nil = new CalcError('#NULL!');
    error.div0 = new CalcError('#DIV/0!');
    error.value = new CalcError('#VALUE?');
    error.ref = new CalcError('#REF!');
    error.name = new CalcError('#NAME?');
    error.num = new CalcError('#NUM!');
    error.na = new CalcError('#N/A');
    error.error = new CalcError('#ERROR!');
    error.data = new CalcError('#GETTING_DATA');
    error.missing = new CalcError('#MISSING');
    error.unknown = new CalcError('#UNKNOWN');
    

    // Cell Model
    function cell(wb, sheetIndex) {
        var cellIndex, addr, rowIndex, colIndex;
    
        if (arguments.length === 3) {
            cellIndex = arguments[2];
            var addr = INDEX2ADDR(cellIndex);
            rowIndex = addr.rowIndex;
            colIndex = addr.colIndex;
            
        } else if (arguments.length === 4) {
            rowIndex = arguments[2];
            colIndex = arguments[3];
            cellIndex = CELLINDEX( rowIndex, colIndex );
        }
        
        if (wb.cells[sheetIndex][cellIndex]) {
            return wb.cells[sheetIndex][cellIndex];
        } else {
    
            this.workbook = wb;
            this.sheetIndex = sheetIndex;
            this.cellIndex = cellIndex;
            this.rowIndex = rowIndex;
            this.colIndex = colIndex;
            
            wb.cells[sheetIndex][cellIndex] = this;
            
            return this;
        }
    };
    
    cell.prototype.valueOf = cell.prototype.val = cell.prototype.value = function() {
        return this.workbook.getValue(this.sheetIndex,
                                      this.rowIndex,
                                      this.colIndex);
    };
    
    cell.prototype.addr = function() {
        return fn.ADDRESS(this.rowIndex+1, this.colIndex+1, 0);
    }
    
    cell.prototype.toString = function() {
        return workbook.sheetName(this.sheetName, this.addr());
    };

    // Range Model
    function range(wb, sheetIndex, topLeft, bottomRight) {
    
        // link back to workbook
        this.workbook = wb;
    
        // the sheet on which the range is set.
        this.sheetIndex = sheetIndex;
        
        if (topLeft.cellIndex > bottomRight.cellIndex) {
            throw Error("topLeft must be smaller then bottomRight");
        }
        
        if (typeof topLeft !== 'function' && !fn.ISCELL(topLeft)) {
            throw Error("topLeft must be function or reference");
        }
    
        if (typeof bottomRight !== 'function' && !fn.ISREF(bottomRight)) {
            throw Error("bottomRight must be function or reference");
        }
    
        if (fn.ISFUNCTION(topLeft) || fn.ISFUNCTION(bottomRight)) {
            this.dynamic = true;
            this.topLeft = topLeft;
            this.bottomRight = bottomRight;
            return this;
        } else {
            this.dynamic = false;
            
            // combine cellIndexes to get a unique key for ranges.
            this.rangeIndex = topLeft.cellIndex + bottomRight.cellIndex;
        }
    
    
        // if already created then return it from the index.
        if (wb.rangeLookup[sheetIndex] &&
            wb.rangeLookup[sheetIndex][this.rangeIndex]) {
            var rangeId = wb.rangeLookup[sheetIndex][this.rangeIndex];
            return wb.ranges[rangeId];
        }
            
        this.rangeId = wb.ranges.length;
        this.sheetIndex = topLeft.sheetIndex;
        this.topLeft = topLeft;
        this.bottomRight = bottomRight;
    
        if (!wb.rangeLookup[sheetIndex]) {
             wb.rangeLookup[sheetIndex] = [];
        }
        
        wb.rangeLookup[sheetIndex][this.rangeIndex] = this.rangeId;
        wb.ranges[this.rangeId] = this;
        
        return this;
    }   
    
    range.prototype.cells = function(mode) {
        var a,b, sheetIndex, wb;                             
        
        a = workbook.resolveCell(this.topLeft);
        b = workbook.resolveCell(this.bottomRight);    
    
        if (a.sheetIndex !== b.sheetIndex) {
            throw Error("topLeft and bottomRight must be on the same sheet.");
        }          
    
        if (a === null || b === null) {
            return [];
        }
    
        wb = a.workbook;
        sheetIndex = a.sheetIndex;
    
        var cells = [];
        var colA = a.colIndex;
        var rowA = a.rowIndex;
    
        var colB = b.colIndex;
        var rowB = b.rowIndex;
    
        for (var rowNum = rowA; rowNum <= rowB; rowNum++) {
            for (var colNum = colA; colNum <= colB; colNum++) {
    
                if (mode === 2) {
                    cells.push(fn.ADDRESS(rowNum +1, colNum+1, 0));
                } else if (mode === 3) {
                    cells.push(wb.sheetName( wb.sheetNames[sheetIndex],
                                                   fn.ADDRESS(rowNum +1, colNum+1, 0) ));
                } else if (mode === 4) {
                    cells.push( new cell( wb, sheetIndex, CELLINDEX( rowNum, colNum ) ) );
                } else {
                    cells.push( CELLINDEX( rowNum, colNum ) );
                }
            }
        }
        
        return cells;
    }
    // return true if the address is inside the range
    range.prototype.hit = function(addr) {
        var a,b,target;
        
        target = workbook.cellInfo(addr);
        a = workbook.resolveCell(this.topLeft);
        b = workbook.resolveCell(this.bottomRight);        
    
        if (a.sheetIndex !== b.sheetIndex) {
            throw Error("topLeft and bottomRight must be on the same sheet.");
        }
    
        return (target.colIndex >= a.colIndex &&
                target.colIndex <= b.colIndex &&
                target.rowIndex >= a.rowIndex &&
                target.rowIndex <= b.rowIndex);
    }
       
    range.prototype.set = function(values) {
    
        if (!fn.ISARRAY(values)) {
            throw TypeError("Only accepts array of values.");
        }
        var topLeft = workbook.resolveCell(this.topLeft);
    
        var cells = this.cells();
        for (var i =0; i < cells.length; i++) {
            this.workbook.set(topLeft.sheetIndex, cells[i], values[i]);
        }
    }
    range.prototype.values = range.prototype.valueOf = function() {
        var a,b, index;
    
        a = workbook.resolveCell(this.topLeft);
        b = workbook.resolveCell(this.bottomRight);
        
        if (a.sheetIndex !== b.sheetIndex) {
            throw Error("topLeft and bottomRight must be on the same sheet.");
        }
    
        if (a === null || b === null) {
            return [];
        }
    
        this.workbook = a.workbook;
        index = this.sheetIndex = a.sheetIndex;
    
        var data = [];
        var colA = a.colIndex;
        var rowA = a.rowIndex;
    
        var colB = b.colIndex;
        var rowB = b.rowIndex;
        
        for (var rowNum = rowA; rowNum <= rowB; rowNum++) {
            // When only 1 column then flatten the output
            if (colA === colB) {
                data[rowNum-rowA] = this.workbook.getValue(index, rowNum, colA);
            } else {
                for (var colNum = colA; colNum <= colB; colNum++) {
                    // When only 1 row then flatten the output
                    if (rowA === rowB) {                        
                        data[colNum-colA] = this.workbook.getValue(index, rowNum, colNum); 
                    } else {
                        if (typeof data[rowNum-rowA] === 'undefined') {
                            data[rowNum-rowA] = [];
                        }
                        data[rowNum-rowA][colNum-colA] = this.workbook.getValue(index, rowNum, colNum);
                    }
                }
            }
        }
    
        return data;
    
    }
    
    range.prototype.toString = function() {
        return workbook.sheetName(this.workbook.sheetNames[this.sheetIndex], this.topLeft.addr) + ":" + this.bottomRight.addr;
    }
    
    
        
    // Workbook Model
    root.workbook = function workbook(config) {        
        
        this.auto = true; // auto-recalculate is the default.
        // planned
        //this.async = true; // enable async updates as default.
        
        if (typeof config === 'object') {
            if (config.hasOwnProperty("name")) { this.name = config.name; }
            if (config.hasOwnProperty("auto")) { this.auto = config.auto; }
            // planned
            //if (config.hasOwnProperty("async")) { this.async = config.async; }
        }
    
        // arrays to store named callbacks for events
        this.callbacks = { 
            set: [ ],
            updated: [ ],
        };
        
        // A map for cells to variable names
        this.namedRange = { };
    
        // formulas/functions metadata
        this.functions = { }; // functions indexed by id
        this.functionLookup = { }; // function ids indexed by exp
    
        // meta-meta systems
        this.cells             = [ ];  // cells by sheetIndex and cellIndex
        this.indirect          = [ ];  // A list of cell indirections: generated by OFFSET and INDIRECT functions
        this.ranges            = [ ];  // static and dynamic ranges by rangeId 
        this.rangeLookup       = { };  // lookup rangeId by sheetIndex, rangeIndex
        this.dynamicranges     = [ ];  // array of dynamic ranges
        this.graph             = [ ];  // a graph of dependencies by cellIndex [dep, prec]
      
        // track metadata about worksheets
        this.sheets = [ ]; // an array of worksheets
        this.sheetNames = [ ]; // an array of worksheet names with same index as sheets array
        this.sheetStore = { }; // a name/value pair of worksheet names to data storage store
        
        // keep track of dirty fields
        this.dirty = []
    }
    
    // Define function library container
    fn = workbook.fn = { };
    workbook.errors = error;
    
    // these functions always need to use .apply(ws, ...)
    workbook.CONTEXTUAL_FUNCTIONS = ["SHEETS", "SHEET", "INDIRECT"]; 
    workbook.ALWAYS_CONTEXTUAL = false; // always use .apply to set this to worksheet
    
    
    
    workbook.prototype.cell = function(sheetIndex, ref) {
        var sheetName,
            sheetIndex = this.resolveSheet(sheetIndex),
            ci = workbook.cellInfo( ref );
    
            return new cell( this,
                             sheetIndex,
                             ci.rowIndex,
                             ci.colIndex );
    
    }
    // Matches $A$1, $A1, A$1 or A1. 
    var cellRegex = /^(?:[$])?([a-zA-Z]+)(?:[$])?([0-9]+)$/;
    var cellInfoMem = {};
    workbook.cellInfo = function(addr) {
    
        if (cellInfoMem.hasOwnProperty(addr)) {
            return cellInfoMem[addr];
        }
    
        var matches = addr.match(cellRegex);
        
        if (matches === null) {
            throw Error("Ref does not match cell reference: " + addr);    
        } else {
            var result = {
                addr: addr,
                row: +matches[2],
                col: matches[1],
                colIndex: workbook.toColumnIndex(matches[1]),
                rowIndex: +matches[2]-1
            };
            cellInfoMem[addr] = result;
            return result;
        }
    }
    var precedents, suppress = false;
    workbook.compile = function(exp, mode) {
        var ast = exp,
            jsCode,
            functionCode,
            f,
            context = this;
        
        mode = mode || 1; // default to compile JSFunction
        
        // convert to AST when string provided
        if (typeof ast === 'string') {
            ast = workbook.parse(this, ast);
        } 
    
        precedents = []; // reset shared precedents
        jsCode =  workbook.compiler(ast);
    
        switch(mode) {
        case 1:
            var id = compiledNumber++;
            f = Function("context", "// formula: " + exp + "\nreturn " + jsCode + "\n//@ sourceURL=formula_function_" +
                         id + ".js");
            f.id = id;
            f.js = jsCode;
            f.exp = exp;
            f.ast = ast;
            f.precedents = precedents;
            
            return f;
        case 2:
            return jsCode;
        case 3:
            functionCode = "// formula: " + exp + "\nfunction(context) {\n  return " + jsCode + ";\n}";
            return functionCode;
        case 4:
            return precedents;
        }
    
    }
    
    // define a compiler function to handle recurse the AST.
    workbook.compiler = function( node ) {
        
        var lhs, rhs, _name, dynamic = false;
    
        var compiler = workbook.compiler;
        
        // The node is expected to be either an operator, function or a value.
        switch(node.type) {
        case 'operator':
            switch(node.subtype) {
            case 'prefix-plus':
                return '+' + compiler( node.operands[0] );
            case 'prefix-minus':
                return '-' + compiler( node.operands[0] );
            case 'infix-add':
                return ("workbook.fn.ADD(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");
            case 'infix-subtract':
                return ("workbook.fn.MINUS(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");
            case 'infix-multiply':
                return ("workbook.fn.MULTIPLY(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");
            case 'infix-divide':
                return ("workbook.fn.DIVIDE(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");
            case 'infix-power':
                return ('workbook.fn.POWER(' + compiler( node.operands[0] ) + ',' 
                        + compiler( node.operands[1] ) + ')')
            case 'infix-concat':
                lhs = compiler( node.operands[0] );
                rhs = compiler( node.operands[1] );
                            
                return "workbook.fn.CONCAT(" + workbook.wrapString(lhs) + ', ' + workbook.wrapString(rhs) + ")";
            case 'infix-eq':
                return ("workbook.fn.EQ(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                
            case 'infix-ne':
                return ("workbook.fn.NE(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                                
            case 'infix-gt':
                return ("workbook.fn.GT(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                                
            case 'infix-gte':
                return ("workbook.fn.GTE(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                                
            case 'infix-lt':
                return ("workbook.fn.LT(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                                
            case 'infix-lte':
                return ("workbook.fn.LTE(" + compiler( node.operands[0] ) + ',' +
                        compiler( node.operands[1]) + ")");                
            }
            throw TypeException("Unknown operator: " + node.subtype);
        case 'group':
            return ('(' +  compiler( node.exp ) + ')');
        case 'function':
            switch (node.name) {
            case 'IF':
                if ( node.args.length > 3) { throw Error("IF sent too many arguments."); }
                if ( node.args.length !== 3) { throw Error("IF expects 3 arguments"); }
                return ('((' + compiler( node.args[0] ) + 
                        ')?' + compiler( node.args[1] ) + 
                        ':' + compiler( node.args[2] ) + ')');
                
            case 'NOT':
                if ( node.args.length !== 1) { throw Error("NOT only accepts one argument"); }
                return 'workbook.fn.NOT(' + compiler( node.args[0] ) + ')';
            case 'AND':
                return ('workbook.fn.AND(' + 
                        node.args.map(function(n){ 
                            return compiler( n );
                        }).join(', ') + ')');                 
            case 'OR':
                return ('workbook.fn.OR(' + 
                        node.args.map(function(n){ 
                            return compiler( n );
                        }).join(', ') + ')');     
    
            default:
                
                _name = function(name) {
                    return workbook.fn.hasOwnProperty(name)?"workbook.fn." + name:name;
                }
                
    
                if ( workbook.ALWAYS_CONTEXTUAL || workbook.CONTEXTUAL_FUNCTIONS.indexOf(node.name) >= 0) {
                    return (_name(node.name) + '.apply( context, ' + 
                            (node.args.length > 0 ? "[" + node.args.map(function(n){ 
                                return compiler( n );
                            }).join(',') + '] )' : '[] )'));
                } else {
                    return (_name(node.name) + '( ' + node.args.map(function(n){ 
                        return compiler( n );
                    }).join(',') + ' )');
                }
                
                
            }
        case 'cell':
            if (typeof precedents !== "undefined" && !suppress) { precedents.push(node); }
    
            if (node.subtype === "remote") {
                return 'context.ref(\"' + node.worksheet + '\", \"' + node.addr + '\")';
            } else {
                return 'context.ref(\"' + node.addr + '\")';
            }
        case 'range':
    
            if (typeof precedents !== "undefined") { precedents.push(node); suppress = true; }
            lhs = compiler(node.topLeft);
            rhs = compiler(node.bottomRight);
            suppress = false;
           
            // anonymous functions are the perfect solution for dynamic ranges but was not immediately obvious to me
            if ( node.topLeft.type === "function" ) {
                lhs = "function() { return (" + lhs + "); }"
            }
    
            if ( node.bottomRight.type === "function" ) {
                rhs = "function() { return (" + rhs + "); }"
            }
        
            return ('context.range( ' + lhs + ', ' + rhs + ' )' );
            
        case 'value':
            switch (node.subtype) {
            case 'array':
                return ('[' + 
                        node.items.map(function(n){ 
                            return compiler( n );
                        }).join(',') + ']');
            case 'string':
                return "'" + node.value.replace(/'/g, "''") + "'";
            case 'variable':
    
                if (precedents && !suppress) { precedents.push(node); }
                
                if (node.subtype === "remote-named") {
                    return 'context.ref(\"' + node.worksheet + '\", \"' + node.value + '\")';
                } else {
                    return 'context.ref(\"' + node.value + '\")';
                }
                
                
            default:
                return node.value;
            }
        }
    }
    
    workbook.prototype.debug = function() {
        var self = this;
        this.on("set", function(sheetName, row, col, newValue, oldValue) {
            display(sheetName + " set from \"" + oldValue +
                    "\" to " + '"' + newValue + '"');
        });
    
        this.on("updated", function(sheetIndex, row, col, newValue, oldValue) {
            display(sheetName + " updated from \"" + oldValue +
                    "\" to " + '"' + newValue + '"');
        });
    
    }
    workbook.prototype.expandGraph = function() {
        throw "TBD";
    };
    workbook.extractCellInfo = function(col, row) {
        var cellInfo, cellName;
        if (typeof col === "number" && typeof row === 'number') {
            return workbook.cellInfo(workbook.toColumn(col) + (row+1).toString());
        } else if (typeof col === "string" && typeof row === 'number') {
            return workbook.cellInfo(col + row.toString());
        } else if (typeof col === "string" && typeof row === 'undefined') {       
            return workbook.cellInfo(col);
        } else {
            throw Error("Expects either row, col or cell name (e.g. A1)");
        }         
    }    
    workbook.prototype.findDependents = function( sheetIndex, cell ) {
        var list = [],
            cellIndex = cell.cellIndex;
    
        var currentItems;        
        
        if (fn.ISARRAY(this.graph)) {
            
            var graph = this.graph;
            
            // update the dependencies in a single loop through the dependency graph.
            
            for (var i = 0; i < graph.length; i++) {
    
                var dependent = graph[i][0];
                var precedent = graph[i][1];
                
                // circular-reference...continue
                if (dependent.sheetIndex === cell.sheetIndex &&
                    dependent.addr === cell.addr) {
                    continue;
                }
    
                // check if precedent matches the cell being updated
                // or if the range of precedents matches the cell.
                if ( ((fn.ISCELL(precedent) &&
                       precedent.sheetIndex === cell.sheetIndex &&
                       precedent.addr === cell.addr) ||
                      (fn.ISRANGE(precedent) &&
                       precedent.sheetIndex === cell.sheetIndex &&
                       precedent.hit(cell.addr))) ) {
    
    
                    list.push(dependent);
                    
                    // concatenate with downstream dependencies
                    list = list.concat(this.findDependents(dependent.sheetIndex, dependent.cellIndex));
                }
            }
            
        }
    
        return list;
    }
    workbook.prototype.get = function(sheetIndex, ref) {
        var sheet;
    
        sheetIndex = this.resolveSheet(sheetIndex);
    
        return this.ref(sheetIndex, ref);
    }
    workbook.prototype.getValue = function(sheetIndex, row, col) {
    
        sheetIndex = this.resolveSheet(sheetIndex);
    
        var sheet = this.sheets[sheetIndex];
        
        switch(this.sheetStore[sheetIndex]) {
        case "col":
            if (typeof sheet[col] !== "undefined") {
                return sheet[col][row];
            }
        case "row":
            if (typeof sheet[row] !== "undefined") {
                return sheet[row][col];
            }
        default:
            return sheet[fn.ADDRESS(row+1, col+1, 0)];
        }
    }
    
    workbook.FormatNumber = {};
    
    workbook.FormatNumber.format_definitions = {}; // Parsed formats are stored here globally
    
    
    // Other constants
    
    workbook.FormatNumber.commands =
        {copy: 1, color: 2, integer_placeholder: 3, fraction_placeholder: 4, decimal: 5,
         currency: 6, general:7, separator: 8, date: 9, comparison: 10, section: 11, style: 12};
    
    
    
    /* *******************
    
       result = workbook.FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char)
    
       ************************* */
    
    workbook.FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char) {
    
        var scfn = workbook.FormatNumber;
    
        var op, operandstr, fromend, cval, operandstrlc;
        var startval, estartval;
        var hrs, mins, secs, ehrs, emins, esecs, ampmstr, ymd;
        var minOK, mpos;
        var result="";
        var thisformat;
        var section, gotcomparison, compop, compval, cpos, oppos;
        var sectioninfo;
        var i, decimalscale, scaledvalue, strvalue, strparts, integervalue, fractionvalue;
        var integerdigits2, integerpos, fractionpos, textcolor, textstyle, separatorchar, decimalchar;
        var value; // working copy to change sign, etc.
    
        rawvalue = rawvalue-0; // make sure a number
        value = rawvalue;
        if (!isFinite(value)) return "NaN";
    
        var negativevalue = value < 0 ? 1 : 0; // determine sign, etc.
        if (negativevalue) value = -value;
        var zerovalue = value == 0 ? 1 : 0;
    
        currency_char = currency_char || DefaultCurrency;
    
        scfn.parse_format_string(scfn.format_definitions, format_string); // make sure format is parsed
        thisformat = scfn.format_definitions[format_string]; // Get format structure
    
        if (!thisformat) throw "Format not parsed error!";
    
        section = thisformat.sectioninfo.length - 1; // get number of sections - 1
    
        if (thisformat.hascomparison) { // has comparisons - determine which section
            section = 0; // set to which section we will use
            gotcomparison = 0; // this section has no comparison
            for (cpos=0; ;cpos++) { // scan for comparisons
                op = thisformat.operators[cpos];
                operandstr = thisformat.operands[cpos]; // get next operator and operand
                if (!op) { // at end with no match
                    if (gotcomparison) { // if comparison but no match
                        format_string = "General"; // use default of General
                        scfn.parse_format_string(scfn.format_definitions, format_string);
                        thisformat = scfn.format_definitions[format_string];
                        section = 0;
                    }
                    break; // if no comparision, matches on this section
                }
                if (op == scfn.commands.section) { // end of section
                    if (!gotcomparison) { // no comparison, so it's a match
                        break;
                    }
                    gotcomparison = 0;
                    section++; // check out next one
                    continue;
                }
                if (op == scfn.commands.comparison) { // found a comparison - do we meet it?
                    i=operandstr.indexOf(":");
                    compop=operandstr.substring(0,i);
                    compval=operandstr.substring(i+1)-0;
                    if ((compop == "<" && rawvalue < compval) ||
                        (compop == "<=" && rawvalue <= compval) ||
                        (compop == "=" && rawvalue == compval) ||
                        (compop == "<>" && rawvalue != compval) ||
                        (compop == ">=" && rawvalue >= compval) ||
                        (compop == ">" && rawvalue > compval)) { // a match
                            break;
                    }
                    gotcomparison = 1;
                }
            }
        }
        else if (section > 0) { // more than one section (separated by ";")
            if (section == 1) { // two sections
                if (negativevalue) {
                    negativevalue = 0; // sign will provided by section, not automatically
                    section = 1; // use second section for negative values
                }
                else {
                    section = 0; // use first for all others
                }
            }
            else if (section == 2) { // three sections
                if (negativevalue) {
                    negativevalue = 0; // sign will provided by section, not automatically
                    section = 1; // use second section for negative values
                }
                else if (zerovalue) {
                    section = 2; // use third section for zero values
                }
                else {
                    section = 0; // use first for positive
                }
            }
        }
    
        sectioninfo = thisformat.sectioninfo[section]; // look at values for our section
    
        if (sectioninfo.commas > 0) { // scale by thousands
            for (i=0; i<sectioninfo.commas; i++) {
                value /= 1000;
            }
        }
        if (sectioninfo.percent > 0) { // do percent scaling
            for (i=0; i<sectioninfo.percent; i++) {
                value *= 100;
            }
        }
    
        decimalscale = 1; // cut down to required number of decimal digits
        for (i=0; i<sectioninfo.fractiondigits; i++) {
            decimalscale *= 10;
        }
        scaledvalue = Math.floor(value * decimalscale + 0.5);
        scaledvalue = scaledvalue / decimalscale;
    
        if (typeof scaledvalue != "number") return "NaN";
        if (!isFinite(scaledvalue)) return "NaN";
    
        strvalue = scaledvalue+""; // convert to string (Number.toFixed doesn't do all we need)
    
        //   strvalue = value.toFixed(sectioninfo.fractiondigits); // cut down to required number of decimal digits
        // and convert to string
    
        if (scaledvalue == 0 && (sectioninfo.fractiondigits || sectioninfo.integerdigits)) {
            negativevalue = 0; // no "-0" unless using multiple sections or General
        }
    
        if (strvalue.indexOf("e")>=0) { // converted to scientific notation
            return rawvalue+""; // Just return plain converted raw value
        }
    
        strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
        if (!strparts) return "NaN"; // if not a number
        integervalue = strparts[1];
        if (!integervalue || integervalue=="0") integervalue="";
        fractionvalue = strparts[2];
        if (!fractionvalue) fractionvalue = "";
    
        if (sectioninfo.hasdate) { // there are date placeholders
            if (rawvalue < 0) { // bad date
                return "??-???-??&nbsp;??:??:??";
            }
            startval = (rawvalue-Math.floor(rawvalue)) * SecondsInDay; // get date/time parts
            estartval = rawvalue * SecondsInDay; // do elapsed time version, too
            hrs = Math.floor(startval / SecondsInHour);
            ehrs = Math.floor(estartval / SecondsInHour);
            startval = startval - hrs * SecondsInHour;
            mins = Math.floor(startval / 60);
            emins = Math.floor(estartval / 60);
            secs = startval - mins * 60;
            decimalscale = 1; // round appropriately depending if there is ss.0
            for (i=0; i<sectioninfo.fractiondigits; i++) {
                decimalscale *= 10;
            } 
            secs = Math.floor(secs * decimalscale + 0.5);
            secs = secs / decimalscale;
            esecs = Math.floor(estartval * decimalscale + 0.5);
            esecs = esecs / decimalscale;
            if (secs >= 60) { // handle round up into next second, minute, etc.
                secs = 0;
                mins++; emins++;
                if (mins >= 60) {
                    mins = 0;
                    hrs++; ehrs++;
                    if (hrs >= 24) {
                        hrs = 0;
                        rawvalue++;
                    }
                }
            }
            fractionvalue = (secs-Math.floor(secs))+""; // for "hh:mm:ss.000"
            fractionvalue = fractionvalue.substring(2); // skip "0."
    
            ymd = workbook.FormatNumber.convert_date_julian_to_gregorian(Math.floor(rawvalue+JulianOffset));
    
            minOK = 0; // says "m" can be minutes if true
            mspos = sectioninfo.sectionstart; // m scan position in ops
            for ( ; ; mspos++) { // scan for "m" and "mm" to see if any minutes fields, and am/pm
                op = thisformat.operators[mspos];
                operandstr = thisformat.operands[mspos]; // get next operator and operand
                if (!op) break; // don't go past end
                if (op==scfn.commands.section) break;
                if (op==scfn.commands.date) {
                    if ((operandstr.toLowerCase()=="am/pm" || operandstr.toLowerCase()=="a/p") && !ampmstr) {
                        if (hrs >= 12) {
                            hrs -= 12;
                            ampmstr = operandstr.toLowerCase()=="a/p" ? PM1 : PM; // "P" : "PM";
                        }
                        else {
                            ampmstr = operandstr.toLowerCase()=="a/p" ? AM1 : AM; // "A" : "AM";
                        }
                        if (operandstr.indexOf(ampmstr)<0)
                            ampmstr = ampmstr.toLowerCase(); // have case match case in format
                    }
                    if (minOK && (operandstr=="m" || operandstr=="mm")) {
                        thisformat.operands[mspos] += "in"; // turn into "min" or "mmin"
                    }
                    if (operandstr.charAt(0)=="h") {
                        minOK = 1; // m following h or hh or [h] is minutes not months
                    }
                    else {
                        minOK = 0;
                    }
                }
                else if (op!=scfn.commands.copy) { // copying chars can be between h and m
                    minOK = 0;
                }
            }
            minOK = 0;
            for (--mspos; ; mspos--) { // scan other way for s after m
                op = thisformat.operators[mspos];
                operandstr = thisformat.operands[mspos]; // get next operator and operand
                if (!op) break; // don't go past end
                if (op==scfn.commands.section) break;
                if (op==scfn.commands.date) {
                    if (minOK && (operandstr=="m" || operandstr=="mm")) {
                        thisformat.operands[mspos] += "in"; // turn into "min" or "mmin"
                    }
                    if (operandstr=="ss") {
                        minOK = 1; // m before ss is minutes not months
                    }
                    else {
                        minOK = 0;
                    }
                }
                else if (op!=scfn.commands.copy) { // copying chars can be between ss and m
                    minOK = 0;
                }
            }
        }
    
        integerdigits2 = 0; // init counters, etc.
        integerpos = 0;
        fractionpos = 0;
        textcolor = "";
        textstyle = "";
        separatorchar = SeparatorChar;
        if (separatorchar.indexOf(" ")>=0) separatorchar = separatorchar.replace(/ /g, "&nbsp;");
        decimalchar = DecimalChar;
        if (decimalchar.indexOf(" ")>=0) decimalchar = decimalchar.replace(/ /g, "&nbsp;");
    
        oppos = sectioninfo.sectionstart;
    
        while (op = thisformat.operators[oppos]) { // execute format
            operandstr = thisformat.operands[oppos++]; // get next operator and operand
    
            if (op == scfn.commands.copy) { // put char in result
                result += operandstr;
            }
    
            else if (op == scfn.commands.color) { // set color
                textcolor = operandstr;
            }
    
            else if (op == scfn.commands.style) { // set style
                textstyle = operandstr;
            }
    
            else if (op == scfn.commands.integer_placeholder) { // insert number part
                if (negativevalue) {
                    result += "-";
                    negativevalue = 0;
                }
                integerdigits2++;
                if (integerdigits2 == 1) { // first one
                    if (integervalue.length > sectioninfo.integerdigits) { // see if integer wider than field
                        for (;integerpos < (integervalue.length - sectioninfo.integerdigits); integerpos++) {
                            result += integervalue.charAt(integerpos);
                            if (sectioninfo.thousandssep) { // see if this is a separator position
                                fromend = integervalue.length - integerpos - 1;
                                if (fromend > 2 && fromend % 3 == 0) {
                                    result += separatorchar;
                                }
                            }
                        }
                    }
                }
                if (integervalue.length < sectioninfo.integerdigits
                    && integerdigits2 <= sectioninfo.integerdigits - integervalue.length) { // field is wider than value
                    if (operandstr == "0" || operandstr == "?") { // fill with appropriate characters
                        result += operandstr == "0" ? "0" : "&nbsp;";
                        if (sectioninfo.thousandssep) { // see if this is a separator position
                            fromend = sectioninfo.integerdigits - integerdigits2;
                            if (fromend > 2 && fromend % 3 == 0) {
                                result += separatorchar;
                            }
                        }
                    }
                }
                else { // normal integer digit - add it
                    result += integervalue.charAt(integerpos);
                    if (sectioninfo.thousandssep) { // see if this is a separator position
                        fromend = integervalue.length - integerpos - 1;
                        if (fromend > 2 && fromend % 3 == 0) {
                            result += separatorchar;
                        }
                    }
                    integerpos++;
                }
            }
            else if (op == scfn.commands.fraction_placeholder) { // add fraction part of number
                if (fractionpos >= fractionvalue.length) {
                    if (operandstr == "0" || operandstr == "?") {
                        result += operandstr == "0" ? "0" : "&nbsp;";
                    }
                }
                else {
                    result += fractionvalue.charAt(fractionpos);
                }
                fractionpos++;
            }
    
            else if (op == scfn.commands.decimal) { // decimal point
                if (negativevalue) {
                    result += "-";
                    negativevalue = 0;
                }
                result += decimalchar;
            }
    
            else if (op == scfn.commands.currency) { // currency symbol
                if (negativevalue) {
                    result += "-";
                    negativevalue = 0;
                }
                result += operandstr;
            }
    
            else if (op == scfn.commands.general) { // insert "General" conversion
    
                // *** Cut down number of significant digits to avoid floating point artifacts:
    
                if (value!=0) { // only if non-zero
                    var factor = Math.floor(Math.LOG10E * Math.log(value)); // get integer magnitude as a power of 10
                    factor = Math.pow(10, 13-factor); // turn into scaling factor
                    value = Math.floor(factor * value + 0.5)/factor; // scale positive value, round, undo scaling
                    if (!isFinite(value)) return "NaN";
                }
                if (negativevalue) {
                    result += "-";
                }
                strvalue = value+""; // convert original value to string
                if (strvalue.indexOf("e")>=0) { // converted to scientific notation
                    result += strvalue;
                    continue;
                }
                strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
                integervalue = strparts[1];
                if (!integervalue || integervalue=="0") integervalue="";
                fractionvalue = strparts[2];
                if (!fractionvalue) fractionvalue = "";
                integerpos = 0;
                fractionpos = 0;
                if (integervalue.length) {
                    for (;integerpos < integervalue.length; integerpos++) {
                        result += integervalue.charAt(integerpos);
                        if (sectioninfo.thousandssep) { // see if this is a separator position
                            fromend = integervalue.length - integerpos - 1;
                            if (fromend > 2 && fromend % 3 == 0) {
                                result += separatorchar;
                            }
                        }
                    }
                }
                else {
                    result += "0";
                }
                if (fractionvalue.length) {
                    result += decimalchar;
                    for (;fractionpos < fractionvalue.length; fractionpos++) {
                        result += fractionvalue.charAt(fractionpos);
                    }
                }
            }
            else if (op==scfn.commands.date) { // date placeholder
                operandstrlc = operandstr.toLowerCase();
                if (operandstrlc=="y" || operandstrlc=="yy") {
                    result += (ymd.year+"").substring(2);
                }
                else if (operandstrlc=="yyyy") {
                    result += ymd.year+"";
                }
                else if (operandstrlc=="d") {
                    result += ymd.day+"";
                }
                else if (operandstrlc=="dd") {
                    cval = 1000 + ymd.day;
                    result += (cval+"").substr(2);
                }
                else if (operandstrlc=="ddd") {
                    cval = Math.floor(rawvalue+6) % 7;
                    result += DayNames3[cval];
                }
                else if (operandstrlc=="dddd") {
                    cval = Math.floor(rawvalue+6) % 7;
                    result += DayNames[cval];
                }
                else if (operandstrlc=="m") {
                    result += ymd.month+"";
                }
                else if (operandstrlc=="mm") {
                    cval = 1000 + ymd.month;
                    result += (cval+"").substr(2);
                }
                else if (operandstrlc=="mmm") {
                    result += MonthNames3[ymd.month-1];
                }
                else if (operandstrlc=="mmmm") {
                    result += MonthNames[ymd.month-1];
                }
                else if (operandstrlc=="mmmmm") {
                    result += MonthNames[ymd.month-1].charAt(0);
                }
                else if (operandstrlc=="h") {
                    result += hrs+"";
                }
                else if (operandstrlc=="h]") {
                    result += ehrs+"";
                }
                else if (operandstrlc=="mmin") {
                    cval = (1000 + mins)+"";
                    result += cval.substr(2);
                }
                else if (operandstrlc=="mm]") {
                    if (emins < 100) {
                        cval = (1000 + emins)+"";
                        result += cval.substr(2);
                    }
                    else {
                        result += emins+"";
                    }
                }
                else if (operandstrlc=="min") {
                    result += mins+"";
                }
                else if (operandstrlc=="m]") {
                    result += emins+"";
                }
                else if (operandstrlc=="hh") {
                    cval = (1000 + hrs)+"";
                    result += cval.substr(2);
                }
                else if (operandstrlc=="s") {
                    cval = Math.floor(secs);
                    result += cval+"";
                }
                else if (operandstrlc=="ss") {
                    cval = (1000 + Math.floor(secs))+"";
                    result += cval.substr(2);
                }
                else if (operandstrlc=="am/pm" || operandstrlc=="a/p") {
                    result += ampmstr;
                }
                else if (operandstrlc=="ss]") {
                    if (esecs < 100) {
                        cval = (1000 + Math.floor(esecs))+"";
                        result += cval.substr(2);
                    }
                    else {
                        cval = Math.floor(esecs);
                        result += cval+"";
                    }
                }
            }
            else if (op == scfn.commands.section) { // end of section
                break;
            }
    
            else if (op == scfn.commands.comparison) { // ignore
                continue;
            }
    
            else {
                result += "!! Parse error !!";
            }
        }
    
        if (textcolor) {
            result = '<span style="color:'+textcolor+';">'+result+'</span>';
        }
        if (textstyle) {
            result = '<span style="'+textstyle+';">'+result+'</span>';
        }
    
        return result;
    
    };
    
    /* *******************
    
       workbook.FormatNumber.parse_format_string(format_defs, format_string)
    
       Takes a format string (e.g., "#,##0.00_);(#,##0.00)") and fills in format_defs with the parsed info
    
       format_defs
       ["#,##0.0"]->{} - elements in the hash are one hash for each format
       .operators->[] - array of operators from parsing the format string (each a number)
       .operands->[] - array of corresponding operators (each usually a string)
       .sectioninfo->[] - one hash for each section of the format
       .start
       .integerdigits
       .fractiondigits
       .commas
       .percent
       .thousandssep
       .hasdates
       .hascomparison - true if any section has [<100], etc.
    
       ************************* */
    
    workbook.FormatNumber.parse_format_string = function(format_defs, format_string) {
    
        var scfn = workbook.FormatNumber;
    
        var thisformat, section, sectionfinfo;
        var integerpart = 1; // start out in integer part
        var lastwasinteger; // last char was an integer placeholder
        var lastwasslash; // last char was a backslash - escaping following character
        var lastwasasterisk; // repeat next char
        var lastwasunderscore; // last char was _ which picks up following char for width
        var inquote, quotestr; // processing a quoted string
        var inbracket, bracketstr, bracketdata; // processing a bracketed string
        var ingeneral, gpos; // checks for characters "General"
        var ampmstr, part; // checks for characters "A/P" and "AM/PM"
        var indate; // keeps track of date/time placeholders
        var chpos; // character position being looked at
        var ch; // character being looked at
    
        if (format_defs[format_string]) return; // already defined - nothing to do
    
        thisformat = {operators: [], operands: [], sectioninfo: [{}]}; // create info structure for this format
        format_defs[format_string] = thisformat; // add to other format definitions
    
        section = 0; // start with section 0
        sectioninfo = thisformat.sectioninfo[section]; // get reference to info for current section
        sectioninfo.sectionstart = 0; // position in operands that starts this section
        sectioninfo.integerdigits = 0; // number of integer-part placeholders
        sectioninfo.fractiondigits = 0; // fraction placeholders
        sectioninfo.commas = 0; // commas encountered, to handle scaling
        sectioninfo.percent = 0; // times to scale by 100
    
        for (chpos=0; chpos<format_string.length; chpos++) { // parse
            ch = format_string.charAt(chpos); // get next char to examine
            if (inquote) {
                if (ch == '"') {
                    inquote = 0;
                    thisformat.operators.push(scfn.commands.copy);
                    thisformat.operands.push(quotestr);
                    continue;
                }
                quotestr += ch;
                continue;
            }
            if (inbracket) {
                if (ch==']') {
                    inbracket = 0;
                    bracketdata=workbook.FormatNumber.parse_format_bracket(bracketstr);
                    if (bracketdata.operator==scfn.commands.separator) {
                        sectioninfo.thousandssep = 1; // explicit [,]
                        continue;
                    }
                    if (bracketdata.operator==scfn.commands.date) {
                        sectioninfo.hasdate = 1;
                    }
                    if (bracketdata.operator==scfn.commands.comparison) {
                        thisformat.hascomparison = 1;
                    }
                    thisformat.operators.push(bracketdata.operator);
                    thisformat.operands.push(bracketdata.operand);
                    continue;
                }
                bracketstr += ch;
                continue;
            }
            if (lastwasslash) {
                thisformat.operators.push(scfn.commands.copy);
                thisformat.operands.push(ch);
                lastwasslash=false;
                continue;
            }
            if (lastwasasterisk) {
                thisformat.operators.push(scfn.commands.copy);
                thisformat.operands.push(ch+ch+ch+ch+ch); // do 5 of them since no real tabs
                lastwasasterisk=false;
                continue;
            }
            if (lastwasunderscore) {
                thisformat.operators.push(scfn.commands.copy);
                thisformat.operands.push("&nbsp;");
                lastwasunderscore=false;
                continue;
            }
            if (ingeneral) {
                if ("general".charAt(ingeneral)==ch.toLowerCase()) {
                    ingeneral++;
                    if (ingeneral == 7) {
                        thisformat.operators.push(scfn.commands.general);
                        thisformat.operands.push(ch);
                        ingeneral=0;
                    }
                    continue;
                }
                ingeneral = 0;
            }
            if (indate) { // last char was part of a date placeholder
                if (indate.charAt(0)==ch) { // another of the same char
                    indate += ch; // accumulate it
                    continue;
                }
                thisformat.operators.push(scfn.commands.date); // something else, save date info
                thisformat.operands.push(indate);
                sectioninfo.hasdate=1;
                indate = "";
            }
            if (ampmstr) {
                ampmstr += ch;
                part=ampmstr.toLowerCase();
                if (part!="am/pm".substring(0,part.length) && part!="a/p".substring(0,part.length)) {
                    ampstr="";
                }
                else if (part=="am/pm" || part=="a/p") {
                    thisformat.operators.push(scfn.commands.date);
                    thisformat.operands.push(ampmstr);
                    ampmstr = "";
                }
                continue;
            }
            if (ch=="#" || ch=="0" || ch=="?") { // placeholder
                if (integerpart) {
                    sectioninfo.integerdigits++;
                    if (sectioninfo.commas) { // comma inside of integer placeholders
                        sectioninfo.thousandssep = 1; // any number is thousands separator
                        sectioninfo.commas = 0; // reset count of "thousand" factors
                    }
                    lastwasinteger = 1;
                    thisformat.operators.push(scfn.commands.integer_placeholder);
                    thisformat.operands.push(ch);
                }
                else {
                    sectioninfo.fractiondigits++;
                    thisformat.operators.push(scfn.commands.fraction_placeholder);
                    thisformat.operands.push(ch);
                }
            }
            else if (ch==".") { // decimal point
                lastwasinteger = 0;
                thisformat.operators.push(scfn.commands.decimal);
                thisformat.operands.push(ch);
                integerpart = 0;
            }
            else if (ch=='$') { // currency char
                lastwasinteger = 0;
                thisformat.operators.push(scfn.commands.currency);
                thisformat.operands.push(ch);
            }
            else if (ch==",") {
                if (lastwasinteger) {
                    sectioninfo.commas++;
                }
                else {
                    thisformat.operators.push(scfn.commands.copy);
                    thisformat.operands.push(ch);
                }
            }
            else if (ch=="%") {
                lastwasinteger = 0;
                sectioninfo.percent++;
                thisformat.operators.push(scfn.commands.copy);
                thisformat.operands.push(ch);
            }
            else if (ch=='"') {
                lastwasinteger = 0;
                inquote = 1;
                quotestr = "";
            }
            else if (ch=='[') {
                lastwasinteger = 0;
                inbracket = 1;
                bracketstr = "";
            }
            else if (ch=='\\') {
                lastwasslash = 1;
                lastwasinteger = 0;
            }
            else if (ch=='*') {
                lastwasasterisk = 1;
                lastwasinteger = 0;
            }
            else if (ch=='_') {
                lastwasunderscore = 1;
                lastwasinteger = 0;
            }
            else if (ch==";") {
                section++; // start next section
                thisformat.sectioninfo[section] = {}; // create a new section
                sectioninfo = thisformat.sectioninfo[section]; // get reference to info for current section
                sectioninfo.sectionstart = 1 + thisformat.operators.length; // remember where it starts
                sectioninfo.integerdigits = 0; // number of integer-part placeholders
                sectioninfo.fractiondigits = 0; // fraction placeholders
                sectioninfo.commas = 0; // commas encountered, to handle scaling
                sectioninfo.percent = 0; // times to scale by 100
                integerpart = 1; // reset for new section
                lastwasinteger = 0;
                thisformat.operators.push(scfn.commands.section);
                thisformat.operands.push(ch);
            }
            else if (ch.toLowerCase()=="g") {
                ingeneral = 1;
                lastwasinteger = 0;
            }
            else if (ch.toLowerCase()=="a") {
                ampmstr = ch;
                lastwasinteger = 0;
            }
            else if ("dmyhHs".indexOf(ch)>=0) {
                indate = ch;
            }
            else {
                lastwasinteger = 0;
                thisformat.operators.push(scfn.commands.copy);
                thisformat.operands.push(ch);
            }
        }
    
        if (indate) { // last char was part of unsaved date placeholder
            thisformat.operators.push(scfn.commands.date);
            thisformat.operands.push(indate);
            sectioninfo.hasdate = 1;
        }
    
        return;
    
    }
    
    
    /* *******************
    
       bracketdata = workbook.FormatNumber.parse_format_bracket(bracketstr)
    
       Takes a bracket contents (e.g., "RED", ">10") and returns an operator and operand
    
       bracketdata->{}
       .operator
       .operand
    
       ************************* */
    
    workbook.FormatNumber.parse_format_bracket = function(bracketstr) {
    
        var scfn = workbook.FormatNumber;
    
        var bracketdata={};
        var parts;
    
        if (bracketstr.charAt(0)=='$') { // currency
            bracketdata.operator = scfn.commands.currency;
            parts=bracketstr.match(/^\$(.+?)(\-.+?){0,1}$/);
            if (parts) {
                bracketdata.operand = parts[1] || DefaultCurrency || '$';
            }
            else {
                bracketdata.operand = bracketstr.substring(1) || DefaultCurrency || '$';
            }
        }
        else if (bracketstr=='?$') {
            bracketdata.operator = scfn.commands.currency;
            bracketdata.operand = '[?$]';
        }
        else if (AllowedColors[bracketstr.toUpperCase()]) {
            bracketdata.operator = scfn.commands.color;
            bracketdata.operand = AllowedColors[bracketstr.toUpperCase()];
        }
        else if (parts=bracketstr.match(/^style=([^"]*)$/)) { // [style=...]
            bracketdata.operator = scfn.commands.style;
            bracketdata.operand = parts[1];
        }
        else if (bracketstr==",") {
            bracketdata.operator = scfn.commands.separator;
            bracketdata.operand = bracketstr;
        }
        else if (AllowedDates[bracketstr.toUpperCase()]) {
            bracketdata.operator = scfn.commands.date;
            bracketdata.operand = AllowedDates[bracketstr.toUpperCase()];
        }
        else if (parts=bracketstr.match(/^[<>=]/)) { // comparison operator
            parts=bracketstr.match(/^([<>=]+)(.+)$/); // split operator and value
            bracketdata.operator = scfn.commands.comparison;
            bracketdata.operand = parts[1]+":"+parts[2];
        }
        else { // unknown bracket
            bracketdata.operator = scfn.commands.copy;
            bracketdata.operand = "["+bracketstr+"]";
        }
    
        return bracketdata;
    
    }
    
    /* *******************
    
       juliandate = workbook.FormatNumber.convert_date_gregorian_to_julian(year, month, day)
    
       From: http://aa.usno.navy.mil/faq/docs/JD_Formula.html
       Uses: Fliegel, H. F. and van Flandern, T. C. (1968). Communications of the ACM, Vol. 11, No. 10 (October, 1968).
       Translated from the FORTRAN
    
       I= YEAR
       J= MONTH
       K= DAY
       C
       JD= K-32075+1461*(I+4800+(J-14)/12)/4+367*(J-2-(J-14)/12*12)
       2    /12-3*((I+4900+(J-14)/12)/100)/4
    
       ************************* */
    
    workbook.FormatNumber.convert_date_gregorian_to_julian = function(year, month, day) {
    
        var juliandate;
    
        juliandate = day-32075+workbook.intFunc(1461*(year+4800+workbook.intFunc((month-14)/12))/4);
        juliandate += workbook.intFunc(367*(month-2-workbook.intFunc((month-14)/12)*12)/12);
        juliandate = juliandate - workbook.intFunc(3*workbook.intFunc((year+4900+workbook.intFunc((month-14)/12))/100)/4);
    
        return juliandate;
    
    }
    
    
    /* *******************
    
       ymd = workbook.FormatNumber.convert_date_julian_to_gregorian(juliandate)
    
       ymd->{}
       .year
       .month
       .day
    
       From: http://aa.usno.navy.mil/faq/docs/JD_Formula.html
       Uses: Fliegel, H. F. and van Flandern, T. C. (1968). Communications of the ACM, Vol. 11, No. 10 (October, 1968).
       Translated from the FORTRAN
    
       ************************* */
    
    workbook.FormatNumber.convert_date_julian_to_gregorian = function(juliandate) {
    
        var L, N, I, J, K;
    
        L = juliandate+68569;
        N = Math.floor(4*L/146097);
        L = L-Math.floor((146097*N+3)/4);
        I = Math.floor(4000*(L+1)/1461001);
        L = L-Math.floor(1461*I/4)+31;
        J = Math.floor(80*L/2447);
        K = L-Math.floor(2447*J/80);
        L = Math.floor(J/11);
        J = J+2-12*L;
        I = 100*(N-49)+I+L;
    
        return {year:I, month:J, day:K};
    
    }
    
    workbook.intFunc = function(n) {
        if (n < 0) {
            return -Math.floor(-n);
        }
        else {
            return Math.floor(n);
        }
    }
    workbook.start = new Date();
    workbook.beat = 0;
    
    workbook.heartbeat = function() {
        workbook.beat++;
    }
    
    setInterval(workbook.loop, 50);
    workbook.hit = function(range, addr) {      
        return range.hit(addr);
    }
    // todo: make sure that formula lookup ignores leading "="
    workbook.prototype.lookupFormulaId = function(exp) {
        if (typeof exp !== "string") {
            throw Error("Formula lookup key must be string");
        }
    
        if (exp[0] === "=") {
            exp = exp.substr(1);
        }
        
        if (this.functionLookup.hasOwnProperty(exp)) {
            return this.functionLookup[exp];
        }
    }   
    workbook.makeFunction = function(name, args, exp) {
        if (typeof name === 'undefined') throw Error("Must provide name to make formula");
        if (typeof exp === 'undefined') { // handle overload for (name, exp)
            exp = args;
            args = "";
        }
        fn[name] = Function("return " + workbook.compile(exp, 2) + ";");
    }
    
    workbook.prototype.nameRange = function(name, ref) {
        var parts;
        if (ref.indexOf('!') > 0) {
            parts = workbook.splitReference(ref);
    
            if (parts.length !== 2) {
                throw Error("Expect two parts in ref");
            }
            
            sheetIndex = this.resolveSheet(parts[0]);
            this.namedRange[name] = this.ref(sheetIndex, parts[1]);
            
        } else {
            throw Error("Expected format Sheet!Ref");
        }
        
        return this;
    }
       
    // register a callback on an event
    workbook.prototype.on = function(eventName, cb) {
        if (this.callbacks.hasOwnProperty(eventName)) {
            this.callbacks[eventName].push(cb);
        } else {
            throw Error("Unknown event: " + eventName);
        }
    }    
    workbook.parse = function(context, exp) {
        if (typeof exp === 'undefined' && typeof context === 'string') {
            exp = context;
            context = {}
        } else if (typeof exp === 'undefined') {
            throw TypeError("No formula!");
        }
    
        if (typeof context !== 'object' && typeof context !== 'function') {
            throw TypeError("Context must be an object or a function!");
        }
    
        parser.yy.context = context;
    
        return parser.parse(exp);
    };
    
    workbook.prototype.populateGraph = function(dep, f) {
        // push the precedents into the graph
        for (var i = 0; i < f.context.precedents.length; i++) {
            this.graph.push([dep, f.context.precedents[i]]);
        }
    }
    workbook.prototype.removeNamedRange = function(name) {
    
        if (!this.namedRange.hasOwnProperty(name)) {
            return this; // name doesn't exist.
        }
        
        var ref =  this.namedRange[name];
        
        delete this.namedRange[name];
    }
    workbook.prototype.range = function(sheetRef, topLeft, bottomRight) {
        var index = this.resolveSheet(sheetRef);
            
        if (arguments.length === 2) {
            r = this.ref(index, topLeft);
        } else if (arguments.length === 3) {
            r = new range(this, index, this.cell(index, topLeft), this.cell(index, bottomRight));
        } else {
            throw Error("Unexpected usage.");
        }
    
        return r;
    }
    workbook.prototype.recalculate = function(sheetIndex, cellIndex) {
        var fid = this.cell[sheetIndex][cellIndex].fid;
        var f = this.functions[fid];
    
        if (!f) {
            return error.na;
        }
    
        return this.run(sheetIndex, f);
    }
    workbook.resolveCell = function(ref) {
        if (fn.ISCELL(ref)) {
            return ref;
        } else if (typeof ref === 'function') {
            return ref();
        } else {
            throw Error("Expects cell or function");
        }
    }      
    workbook.prototype.resolveSheet = function(sheetRef) {
        var sheetIndex;
        if (fn.ISNUMBER(sheetRef)) {
            return sheetRef; // short circuit
        } else if (fn.ISTEXT(sheetRef)) { // sheet name to index
            sheetIndex = this.sheetNames.indexOf(sheetRef);
        } else if (fn.ISOBJECT(sheetRef)) { // sheet object to index
            sheetIndex = this.sheets.indexOf(sheetRef);
        }
        
        // ensure correct resolution
        if (typeof sheetIndex === "undefined" ) {
            throw Error("Sheet index is undefined");
        }
        
        if ( sheetIndex < 0 ) {
            throw Error("Sheet index is negative");
        }
    
        return sheetIndex;
        
    }
    // Get the col and row for a cell (e.g. A1 or $A$1).
    workbook.prototype.ref = function(sheetIndex, ref) {
        var result;
        
        if (!ref) { throw Error("ref is undefined"); }
    
        // handle named ranges and references that are cell objects
        if (this.namedRange.hasOwnProperty(ref)) {
            return this.namedRange[ref];
        } else if (fn.ISCELL(cell)) {
            ref = cell.addr;
        }
    
        if (ref.indexOf(':') >= 0) { // handle ranges
            parts = ref.split(':');
            if (parts.length !== 2) { throw Error("parts should have 2 length."); }
            result = new range(this, sheetIndex, this.ref(sheetIndex, parts[0]), this.ref(sheetIndex, parts[1]));
    
        } else { // handle cells
    
            result = this.cell(sheetIndex, ref);
        }
    
        return result;
    }
       
    workbook.run = workbook.prototype.run = function(sheetRef, exp) {            
        var f,
            context={ workbook: this, precedents: [] },
            index;
    
        // handle case when only 1 argument is passed to function
        if (arguments.length === 1) {
    
            if (typeof sheetRef !== "string") {
                throw new Error("Argument must be string if only 1 argument is passed to workbook.run");
            }
            
            exp = sheetRef;
            context.sheet = {};
        } else {
            index = this.resolveSheet(sheetRef);
            context.sheet = this.sheets[index];
            context.sheetName = this.sheetNames[index];
            context.sheetIndex = index;
        }
    
    
        context.range = function(topLeft, bottomRight) {         
           var r = new range(context.workbook, context.sheetIndex, topLeft, bottomRight);
           if (r.dynamic) {
               this.workbook.dynamicranges.push(r);
           }
           this.precedents.push(r);
           return r;
        }
    
        context.ref = function() {
            var sheetName, addr, ref, parts;
            if (arguments.length === 2) {
                sheetName = arguments[0];
                addr = arguments[1];
                ref = this.workbook.ref(sheetName, addr);
            } else {
                addr = arguments[0];
                ref = this.workbook.ref(context.sheetIndex, addr);
            }
    
            this.precedents.push(ref);
            return ref;
        }
    
        if (typeof exp === "string") { 
    
            if (this.constructor.name === "workbook") {
                f = this.lookupFormulaId(exp);
                
                if (!f) {
                    f = workbook.compile.apply(context, [exp]);
    
                    if (exp[0] === "=") {
                        exp = exp.substr(1);
                    }
                    
                    // Intentional programming chases its own tail.
                    // the ref to a definition of a set of rules
                    this.functions[f.id] = f;
    
                    // index for faster access
                    this.functionLookup[exp] = f.id;
    
                } else {
                    f = this.functions[f];
                }
            } else { // always compile when constructor not workbook
                f = workbook.compile.apply(context, [exp]);
            }
    
        } else if (typeof exp === "function") {
            f = exp;
        } else {
            throw Error("exp expected to be string or function");
        }
    
        f.context = context;
        return f(context);
    };   
    
    
    function autoName(wb) {
        return "Sheet" + (wb.sheets.length + 1);
    }
    
    function autoSheet(store) {
        switch(store) {
        case "col":
        case "row":
            return [];
            break;
        default:
            return {}
            break;
        }
    }
    
    workbook.prototype.sheet = function(config) {
        var index = this.sheets.length, ws, name, wb = this, store = "object";
    
        
        if (config) {
            if (config.hasOwnProperty("name")) {
                name = config.name;
            } else {
                name = autoName(this);
            }
    
            if (config.hasOwnProperty("store")) {
                store = config.store;
            }
            
            if (config.hasOwnProperty("data")) {
                ws = config.data;
            } else {
                ws = autoSheet(store);
            }
    
    
        } else {
            name = autoName(this);
            ws = autoSheet();
        }
        
        this.sheetNames.push(name);
        this.sheets.push(ws);
        this.sheetStore[index] = store;
        this.cells[index] = [ ];
    
        return ws;
    
    }
    workbook.sheetName = function(name, cell) {
        return ((name.indexOf(' ') > 0 ?
                 ("'" + name + "'!" + cell) :
                 (name + "!" + cell)));
        
    }
    
    // A function to split Sheet!Cell or Sheet!Ref into 2 parts
    workbook.splitReference = function(ref) {
        var parts = [], worksheet;
        
        if (typeof ref !== "string") {
            throw "expects string";
        }
    
        parts = ref.split('!');
    
        if (parts.length !== 2) {
            throw "reference should have two parts";
        }
        
        worksheet = parts[0];
    
        // strip leading and trailing ' if present
        if (worksheet.indexOf("'") === 0) {
            parts[0] = worksheet.substring(1, worksheet.length-1);
        }
    
        return parts;
        
    }     
    
    workbook.prototype.set = function() {
        var ws, wsName, ref, row, col, value, ci, sheetIndex, oldValue, exp;
    
        if (arguments.length < 2 || arguments.length > 4) {
            throw Error("set expects 2..4 arguments. actual: " + arguments.length);
        }
    
        sheetIndex = this.resolveSheet(arguments[0]);
    
    
        if (arguments.length === 2) {
    
            for (var key in arguments[1]) {
                this.set(sheetIndex, key, arguments[1][key]);
            }
    
            return;
            
        } else if (arguments.length === 3) {
            
            ref = arguments[1];
            value = arguments[2];
    
            // handle named ranges
            if (typeof ref === "number") {
                ref = new cell(this, sheetIndex, ref);
            } else {
                if (this.namedRange.hasOwnProperty(ref)) {
                    ref = this.namedRange[ref];
                } else {
                    ref = this.ref(sheetIndex, ref);
                }
    
                if (fn.ISRANGE(ref)) {
                    ref.set(value);
                    return;
                }
            }
            
        } else if (arguments.length === 4) {
            row = arguments[1];
            col = arguments[2];
            value = arguments[3];
    
            ref = new cell(this, sheetIndex, row, col);
        }
        
        if (typeof value === "string" && value[0] === "=") {
            exp = value;
            value = this.setFormula(sheetIndex, ref, exp);
        } 
        
        oldValue = this.setValue(sheetIndex, ref, value);
        this.triggerEvent("set", [this.sheetNames[sheetIndex], ref, oldValue, value]);
        
        this.update( sheetIndex, ref );
    
        return this;
    };
    workbook.prototype.setFormula = function(sheetIndex, ref, exp) {
        var ref, addr,
            f, cellIndex = ref.cellIndex;
        
        // run the expression
        var result = this.run(this.sheets[sheetIndex], exp);
    
        f = this.lookupFormulaId(exp);
        if ( typeof f === "number" ) {
            this.cells[sheetIndex][cellIndex].fid = f;
        } else {
            throw Error("Cannot find function for exp: " + exp);
        }
    
        return result;
    }   
    // row and col expected in 0 base. first column is 0 and first row is 0.
    workbook.prototype.setValue = function(sheetIndex, cell, value) {
        var col = cell.colIndex,
            row = cell.rowIndex;
        
        if (row >= MAX_ROWS) {
            throw Error("Exceeds maximum row");
        }
    
        if (col >= MAX_COLS) {
            throw Error("Exceeds maximum col");
        }
        
        var ws = this.sheets[sheetIndex], oldValue, addr;
    
        switch(this.sheetStore[sheetIndex]) {
        case "col":
            if (!ws[col]) { ws[col] = []; }
            oldValue = ws[col][row];
            ws[col][row] = value;
            break;
        case "row":
            if (!ws[row]) { ws[row] = []; }
            oldValue = ws[row][col]
            ws[row][col] = value;
            break;
        default:
            addr = cell.addr();
            oldValue = ws[addr];
            ws[addr] = value;
        }    
        
    
        return oldValue;
        
    }   
    var toColumnMem = {};
    workbook.toColumn = function( column_index ) {
    
        if (toColumnMem.hasOwnProperty(column_index)) {
            return toColumnMem[ column_index ];
        }
        
        // The column is determined by applying a modified Hexavigesimal algorithm.
        // Normally BA follows Z but spreadsheets count wrong and nobody cares. 
    
        // Instead they do it in a way that makes sense to most people but
        // is mathmatically incorrect. So AA follows Z which in the base 10
        // system is like saying 01 follows 9. 
    
        // In the least significant digit
        // A..Z is 0..25
    
        // For the second to nth significant digit
        // A..Z is 1..26
    
        var converted = ""
        ,secondPass = false
        ,remainder;
    
        value = Math.abs(column_index);
        
        do {
            remainder = value % 26;
    
            if (secondPass) {
                remainder--;
            }
            
            converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;
            value = Math.floor((value - remainder) / 26);
    
            secondPass = true;
        } while (value > 0);
    
        toColumnMem[ column_index ] = converted;    
        return converted;
    }
    
    // Many thanks to http://en.wikipedia.org/wiki/Hexavigesimal for explaining the number theory
    // and the basic structure of the algorithm (modified base26).
    workbook.toColumnIndex = function(column) {
    
        // convert the column name into the column index
    
        // see toColumn for rant on why this is sensible even though it is illogical.
        var s = 0, secondPass;
    
        if (column != null && column.length > 0) {
    
            s = column.charCodeAt(0) - 'A'.charCodeAt(0);
            
            for (var i = 1; i < column.length; i++) {
                s+=1 // compensate for the weirdos that invented spreadsheet column naming
                s *= 26;
                s += column.charCodeAt(i) - 'A'.charCodeAt(0);
                secondPass = true;
            }
            
        } else {
            throw Error("Must provide a column");
        }
    
        return s;
    
    }
    // invokes all of the callbacks registered by callers
    workbook.prototype.triggerEvent = function(eventName, args) {
        this.callbacks[eventName].forEach(function(cb) {
            cb.apply(this, args); 
        });
    }     
    workbook.prototype.update = function(sheetIndex, cell) {
        var cellIndex = cell.cellIndex,
            rowIndex = cell.rowIndex,
            colIndex = cell.colIndex;
            dirtyCells = this.findDependents(sheetIndex, cell);
    
        if (dirtyCells) {
            for(var i = 0; i < dirtyCells.length; i++) {
                cellToUpdate = dirtyCells[i];
    
                oldValue = this.getValue(sheetIndex, rowIndex, colIndex);
                newValue = this.recalculate(sheetIndex, cellIndex);
                
                if (oldValue !== newValue) {
    
                    if (fn.ISCELL(newValue) || oldValue !== newValue.valueOf()) {
                        this.set(sheetIndex,
                                 rowIndex,
                                 colIndex,
                                 newValue.valueOf());
                        
                        // Trigger notification on the callbacks
                        this.triggerEvent("updated",
                                          [sheetIndex,
                                           rowIndex,
                                           colIndex,
                                           newValue,
                                           oldValue]);
    
                    }
                }
            }
        }
    }
    workbook.wrapString = function(s) {
    
        if (s[0] == "'" && s[s.length-1] === "'") {
            return s;
        }
        
        return 'String(' + s + '.valueOf())';
    
    }
        
    // Built-in Functions
    fn.flatten = function(array){
        var a = array;
        if (a.constructor.name === "range") {
            var a = a.values();
        }
        
        var r = [];
        
        function _flatten(a) {    
            for(var i=0; i<a.length; i++){
                if (typeof a[i] === "undefined" || a[i] === null) {
                    continue; // empty cell or variable...just keep rolling
                } else if(a[i].constructor.name === "range") {
                    _flatten(a[i].values());
                } else if(a[i].constructor == Array) {
                    _flatten(a[i]);
                } else {
                    r.push(a[i]);
                }
            }
            return r;
        }
    
        return _flatten(a);
    }
    fn.isAnyError = function() {
        var n = arguments.length;
        while (n--) {
            if (arguments[n] instanceof Error) {
                return true;
            }
        }
        return false;
    };
    fn.parseNumber = function(string) {
        if (string === undefined || string === '') {
            return error.value;
        }
        if (!isNaN(string)) {
            return parseFloat(string);
        }
        return error.value;
    };
    fn.parseDate = function(date) {
        if (typeof date === 'string') {
            date = new Date(date);
            if (!isNaN(date)) {
                return date;
            }
        } else if (date === date) {
            if (date instanceof Date) {
                return new Date(date);
            }
            var d = parseInt(date, 10);
            if (d < 0) {
                return error.num;
            }
            if (d <= 60) {
                return new Date(d1900.getTime() + (d - 1) * MilliSecondsInDay);
            }
            return new Date(d1900.getTime() + (d - 2) * MilliSecondsInDay);
        }
    
        return error.value;
    };
    fn.parseBool = function(bool) {
        if (typeof bool === 'boolean') {
            return bool;
        }
    
        if (bool instanceof Error) {
            return bool;
        }
    
        if (typeof bool === 'number') {
            return bool !== 0;
        }
    
        if (typeof bool === 'string') {
            var up = bool.toUpperCase();
            if (up === 'TRUE') {
                return true;
            }
    
            if (up === 'FALSE') {
                return false;
            }
        }
    
        if (bool instanceof Date && !isNaN(bool)) {
            return true;
        }
    
        return error.value;
    };
    fn.serial = function(date) {
        var addOn = (date > -2203891200000)?2:1;
        return Math.ceil((date - d1900) / MilliSecondsInDay) + addOn;
    }
    // DONT THINK THIS WORKS!
    fn.serialTime = function(date) {
        var addOn = (date > -2203891200000)?2:1;
        return ((date - d1900) / MilliSecondsInDay) + addOn;
    }
    fn.validDate = function(d) {
        return d && d.getTime && !isNaN(d.getTime());
    }
    
    // credit to http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    // rfc4122 version 4 compliant solution
    fn.GUID = function(){
        var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });             
        return guid;
    };
    fn.DAY = function (date) {
        if (typeof date === "string") {
            return new Date(date).getDate();
        } else {
            return fn.parseDate(date).getDate();
        }
    }          
    fn.DATE = function(year, month, day) {
        return fn.serial(new Date(year, month-1, day));
    }
    fn.DATEDIF = function(start_date, end_date, unit) {
        var s, e; // start and end serial
        
        if (typeof start_date === "string") {
            start_date = fn.parseDate(start_date);
            s =  fn.serial(start_date);
        } else {
            s = start_date;
            start_date = fn.parseDate(s);
        }
    
        if (typeof end_date === "string") {
            end_date = fn.parseDate(end_date);
            e =  fn.serial(end_date);
        } else {
            e = end_date;
            end_date = fn.parseDate(e);
        }
    
        if (end_date === start_date) {
            return 0;
        }
    
        if (end_date < start_date) {
            return error.num;
        }
    
        switch (unit) {
        case "Y":
            return end_date.getFullYear() - start_date.getFullYear();
        case "M":
            return (((end_date.getFullYear() - start_date.getFullYear()) * 12)
                    - (start_date.getMonth())
                    + end_date.getMonth());
        case "D":
            return e - s;
        case "MD":
            return "Not supported"
        case "YM":
            return "Not supported"
        case "YD":
            return "Not supported"
        }
    
        return error.na;
    }
    
    fn.DATEVALUE = function () {
        if (!arguments.length) {
            return new Date();
        }
    
        if (arguments.length === 1) {
            return fn.serial(new Date(arguments[0]));
        }
    
        var args = arguments;
        args[1] = args[1] - 1; // Monthes are between 0 and 11.
        return fn.serial(new (Date.bind.apply(Date, [Date].concat([].splice.call(args, 0))))());
    }          
    fn.DAYS360 = function(start_date, end_date, method) {
        method = typeof method === 'undefined' ? false : fn.parseBool(method);
        start_date = fn.parseDate( fn.DATEVALUE(start_date) );
        end_date = fn.parseDate( fn.DATEVALUE(end_date) );
    
        if (start_date instanceof Error) {
            return start_date;
        }
        if (end_date instanceof Error) {
            return end_date;
        }
        if (method instanceof Error) {
            return method;
        }
        var sm = start_date.getMonth();
        var em = end_date.getMonth();
        var sd, ed;
        if (method) {
            sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
            ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
        } else {
            var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
            var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
            sd = start_date.getDate() === smd ? 30 : start_date.getDate();
            if (end_date.getDate() === emd) {
                if (sd < 30) {
                    em++;
                    ed = 1;
                } else {
                    ed = 30;
                }
            } else {
                ed = end_date.getDate();
            }
        }
        return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
            30 * (em - sm) + (ed - sd);
    };
    fn.EDATE = function(start_date, months) {
        start_date = fn.parseDate(start_date);
        if (start_date instanceof Error) {
            return start_date;
        }
        if (isNaN(months)) {
            return error.value;
        }
        months = parseInt(months, 10);
        start_date.setMonth(start_date.getMonth() + months);
        return fn.serial(start_date);
    };
    fn.EOMONTH = function(start_date, months) {
        start_date = fn.parseDate(start_date);
        if (fn.ISERROR(start_date)) {
            return error.na;
        }
    
        if (months !== months) { // NaN(months)
            return error.value;
        }
    
        months = parseInt(months, 10);
        return fn.serial(new Date(start_date.getFullYear(), start_date.getMonth() + months+1, 0));
    
    };
    fn.HOUR = function(serial_num) {
        // remove numbers before decimal place and convert fraction to 24 hour scale.
        return fn.FLOOR((serial_num - fn.FLOOR(serial_num)) * 24);
    }
    fn.ISLEAPYEAR = function(date) {
        date = fn.parseDate(date);
        var year = date.getFullYear();
        return (((year % 4 === 0) && (year % 100 !== 0)) ||
                (year % 400 === 0));
    }
    fn.ISOWEEKNUM = function(date) {
        date = fn.parseDate(date);
        if (date instanceof Error) {
            return date;
        }
    
        date.setHours(0, 0, 0);
        date.setDate(date.getDate() + 4 - (date.getDay() || 7));
        var yearStart = new Date(date.getFullYear(), 0, 1);
        return Math.ceil((((date - yearStart) / MilliSecondsInDay) + 1) / 7);
    };    
    fn.MINUTE = function(serial_num) {
    
        var startval = (serial_num-Math.floor(serial_num)) * SecondsInDay; // get date/time parts
        var hrs = Math.floor(startval / SecondsInHour);
        var startval = startval - hrs * SecondsInHour;
    
        return Math.floor(startval / 60);
    }
    fn.MONTH = function (timestamp) {
        var date;
        if (typeof timestamp === "string") {
            date = fn.parseDate(fn.DATEVALUE(timestamp));
        } else {
            date = fn.parseDate(timestamp);
        }
    
        if (date && !fn.ISERROR(date)) {
            return date.getMonth() + 1;
        } else {
            return date;
        }
    
    }    
    fn.NOW = function() {
        return fn.serialTime(new Date());
    }         
    fn.SECOND = function(serial_num) {
    
        var startval = (serial_num-Math.floor(serial_num)) * SecondsInDay; // get date/time parts
        var hrs = Math.floor(startval / SecondsInHour);
        var startval = startval - hrs * SecondsInHour;
        var mins =  Math.floor(startval / 60);
        return Math.floor(startval - mins * 60);
    }
    fn.TIME = function(hour, minute, second) {
      hour = fn.parseNumber(hour);
      minute = fn.parseNumber(minute);
      second = fn.parseNumber(second);
      if (fn.isAnyError(hour, minute, second)) {
        return error.value;
      }
      if (hour < 0 || minute < 0 || second < 0) {
        return error.num;
      }
      return (((SecondsInHour * hour) + (SecondsInMinute * minute) + second) / SecondsInDay);
    };
    
    fn.TIMEVALUE = function(time_text) {
        // The JavaScript new Date() does not accept only time.
        // To workaround the issue we put 1/1/1900 at the front.
    
        var last2Characters = time_text.substr(-2).toUpperCase();
        var date;
    
        if (time_text.length === 7 && (last2Characters === AM || last2Characters === PM)) {
            time_text = "1/1/1900 " + time_text.substr(0, 5) + " " + last2Characters;
        } else if (time_text.length < 9) {
            time_text = "1/1/1900 " + time_text;
        }
    
        date = new Date(time_text);
        
        if (date instanceof Error) {
            return date;
        }
        
        return (SecondsInHour * date.getHours() +
                SecondsInMinute * date.getMinutes() +
                date.getSeconds()) / SecondsInDay;
    };
    fn.TODAY = function() {
        return fn.FLOOR(fn.NOW())
    }    
    fn.YEAR = function (serial_num) {
        return Math.floor(serial_num / 365) + 1900;
    }
    fn.YEARFRAC = function(start_date, end_date, basis) {
        start_date = fn.parseDate(start_date);
        if (start_date instanceof Error) {
            return start_date;
        }
        end_date = fn.parseDate(end_date);
        if (end_date instanceof Error) {
            return end_date;
        }
    
        basis = basis || 0;
        var sd = start_date.getDate();
        var sm = start_date.getMonth() + 1;
        var sy = start_date.getFullYear();
        var ed = end_date.getDate();
        var em = end_date.getMonth() + 1;
        var ey = end_date.getFullYear();
    
        switch (basis) {
        case 0:
            // US (NASD) 30/360
            if (sd === 31 && ed === 31) {
                sd = 30;
                ed = 30;
            } else if (sd === 31) {
                sd = 30;
            } else if (sd === 30 && ed === 31) {
                ed = 30;
            }
            return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
        case 1:
            // Actual/actual
            var feb29Between = function(date1, date2) {
                var year1 = date1.getFullYear();
                var mar1year1 = new Date(year1, 2, 1);
                if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
                    return true;
                }
                var year2 = date2.getFullYear();
                var mar1year2 = new Date(year2, 2, 1);
                return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
            };
            var ylength = 365;
            if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
                if ((sy === ey && isLeapYear(sy)) ||
                    feb29Between(start_date, end_date) ||
                    (em === 1 && ed === 29)) {
                    ylength = 366;
                }
                return daysBetween(start_date, end_date) / ylength;
            }
            var years = (ey - sy) + 1;
            var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
            var average = days / years;
            return daysBetween(start_date, end_date) / average;
        case 2:
            // Actual/360
            return daysBetween(start_date, end_date) / 360;
        case 3:
            // Actual/365
            return daysBetween(start_date, end_date) / 365;
        case 4:
            // European 30/360
            return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
        }
    };
    fn.BIN2DEC = function(value) {
        var valueAsString;
    
        if (typeof value === "string") {
            valueAsString = value;
        } else if (typeof value !== "undefined") {
            valueAsString = value.toString();
        } else {
            return error.NA;
        }
        
        if (valueAsString.length > 10) return error.NUM;
    
        if (valueAsString.length === 10 && valueAsString[0] === '1') {
            return parseInt(valueAsString.substring(1), 2) - 512;
        }
    
        // Convert binary number to decimal
        return parseInt(valueAsString, 2);
        
    };
    
    fn.IF = function(true_or_false, true_value, false_value) {
        return ((true_or_false) ? true_value : false_value);
    }
    fn.NOT = function(logical) {
        return !logical;
    }
    fn.AND = function() {
        var result = true;
        var list = fn.flatten(arguments);
        for (var i = 0; i < list.length; i++) {
            result = result && arguments[i];
            if (!result) return false;
        }
        return true;
    }
    
    fn.OR = function() {
        var result = true;
        var list = fn.flatten(arguments);
        for (var i = 0; i < list.length; i++) {
            result = result && arguments[i];
            if (result) return true;
        }
        return false;
    }
    
    fn.IFERROR = function(value, valueIfError) {
        if (fn.ISERROR(value)) {
            return valueIfError;
        }
        return value;
    };
    fn.IFNA = function(value, value_if_na) {
        return value === error.na ? value_if_na : value;
    };
    fn.XOR = function() {
        var args = fn.flatten(arguments);
        var result = 0;
        for (var i = 0; i < args.length; i++) {
            if (args[i]) {
                result++;
            }
        }
        return (result & 1) ? true : false;
    };
    fn.SWITCH = function () {
        var result;
        if (arguments.length > 0)  {
            var targetValue = arguments[0];
            var argc = arguments.length - 1;
            var switchCount = Math.floor(argc / 2);
            var switchSatisfied = false;
            var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];
    
            if (switchCount) {
                for (var index = 0; index < switchCount; index++) {
                    if (targetValue === arguments[index * 2 + 1]) {
                        result = arguments[index * 2 + 2];
                        switchSatisfied = true;
                        break;
                    }
                }
            }
    
            if (!switchSatisfied && defaultClause) {
                result = defaultClause;
            }
        }
    
        return result;
    };
    // MORE LISPY Fucking shit in here...haha
    fn.CHOOSE = function(index) {
        if (arguments.length < 2) {
            return error.value;
        }
    
        var values = [ ];
        for (var i = 1; i < arguments.length; i++) {
            var item = arguments[i];
            if (fn.ISRANGE(item)) {
                values = values.concat( item.values() );
            } else {
                values.push(item);
            }
        }
    
        var retVal = values[index-1];
    
        if (fn.ISCELL(retVal)){
            return (retVal).valueOf();
        }
    
        return retVal;
        
    }
    
    fn.ADDRESS = function(row, col, absolute_relative_mode, use_a1_notation, sheet) {
        switch(absolute_relative_mode) {
        case 0:
            return workbook.toColumn(col-1) + (row).toString()
        case 2:
            return workbook.toColumn(col-1) + "$" + (row).toString()
        case 3:
            return "$" + workbook.toColumn(col-1) + (row).toString()
        default:
            return "$" + workbook.toColumn(col-1) + "$" + (row).toString()
        }
    }
    fn.COLUMN = function(ref) {
    
        if (fn.ISTEXT(ref)) {
            return workbook.extractCellInfo(ref).col;
        }
    
        if (fn.ISCELL(ref)) {
            return ref.col;
        }
    
        return error.na;
    }
    fn.COLUMNS = function(ref) {
        var cols = 0;
        
        if (fn.ISARRAY(ref)) {
    
            for (var i = 0; i < ref.length; i++) {
                if (cols === 0) {
                    if (!fn.ISARRAY(ref[i])) {
                        return ref.length;
                    }
                    cols = ref[i].length;
                } else if (cols === ref[i].length) {
                    continue;
                } else { // not all columns name size; raise error
                    return error.value;
                }
            }
    
            return cols;
        }
    
        if (fn.ISRANGE(ref)) {
            return ref.bottomRight.colIndex - ref.topLeft.colIndex;
        }
    
        return error.na;
        
    }
    fn.LOOKUP = function() {
        var lookup_value, lookup_array, lookup_vector, results_vector;
        if (arguments.length === 2) { // array form
            var wide = false;
            
            lookup_value = arguments[0].valueOf();
            lookup_array = arguments[1];
    
            if (fn.ISRANGE(lookup_array)) {
                lookup_array = lookup_array.valueOf();
            }
    
            for (var i = 0; i < lookup_array.length; i++) {
                if (typeof lookup_array[i] !== 'undefined' && lookup_value === lookup_array[i].valueOf()) {
                    return lookup_array[i];
                }
            }
    
        } else if (arguments.length === 3) { // vector form`
            lookup_value = arguments[0].valueOf();
            lookup_vector = arguments[1];
            results_vector = arguments[2];
    
            if (fn.ISRANGE(lookup_vector)) {
                lookup_vector = lookup_vector.valueOf();
            }
    
            if (fn.ISRANGE(results_vector)) {
                results_vector = results_vector.valueOf();
            }
            
            for (var i = 0; i < lookup_vector.length; i++) {
                if (typeof lookup_vector[i] !== 'undefined' && lookup_value === lookup_vector[i].valueOf()) {
                    return results_vector[i];
                }
            }
    
        }
    
        return error.na;
    
    }
    fn.HLOOKUP = function(needle, table, index, exactmatch) {
        if (fn.ISRANGE(table)) {
            table = table.valueOf();
        }
    
        if (fn.ISCELL(needle)) {
            needle = needle.valueOf();
        }
    
        if (typeof needle === "undefined" || fn.ISBLANK(needle)) {
            return null;
        }
    
        index = index || 0;           
    
        var row = table[0];               
        for (var i = 0; i < row.length; i++){               
    
            if ((exactmatch && row[i]===needle) ||
                row[i].toLowerCase().indexOf(needle.toLowerCase()) !== -1) {
                return (index < (table.length+1) ? table[index-1][i] : table[0][i]);
            }
        }             
    
        return error.na;
    }
    fn.INDIRECT = function(cell_string) {
        return this.cell(cell_string);
    }
    fn.VLOOKUP = function(needle, table, index, exactmatch) {             
    
        if (fn.ISRANGE(table)) {
            table = table.valueOf();
        }
    
        if (fn.ISCELL(needle)) {
            needle = needle.valueOf();
        }
    
        if (fn.ISERROR(needle) || fn.ISBLANK(needle)) {
            return needle;
        }
    
        index = index || 0;           
        exactmatch = exactmatch || false;             
        for (var i = 0; i < table.length; i++){               
            var row = table[i];               
            if ((exactmatch && row[0]===needle) ||
                ((row[0] === needle) ||
                 (typeof row[0] === "string" && row[0].toLowerCase().indexOf(needle.toLowerCase()) != -1) )) {
                return (index < (row.length+1) ? row[index-1] : row[0]);
            }
        }
        
        return error.na;
    
    }                 
    fn.MATCH = function(lookup_reference, array_reference, matchType) {
        var lookupArray, lookupValue;
        var isRef=false;
    
    
        // Gotta have only 2 arguments folks!
        if (arguments.length === 2) {
            matchType = 1;
        }
    
        // Find the lookup value inside a worksheet cell, if needed.
        if (fn.ISREF(lookup_reference)) {
            lookupValue = lookup_reference.valueOf();
        } else {
            lookupValue = lookup_reference;
        }
        
    
        // Find the array inside a worksheet range, if needed.
        if (fn.ISREF(array_reference)) {
            isRef = true;
            lookupArray = array_reference.values();
        } else if (fn.ISARRAY(array_reference)) {
            lookupArray = array_reference;
        } else {
            return error.na;
        }
    
        // Gotta have both lookup value and array
        if (!lookupValue && !lookupArray) {
            return error.na;
        }
    
        // Bail on weird match types!
        if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
            return error.na;
        }
        
        
        
        var index;
        var indexValue;
        
        
        for (var idx = 0; idx < lookupArray.length; idx++) {
            if (matchType === 1) {
                if (lookupArray[idx] === lookupValue) {
                    return idx + 1;
                } else if (lookupArray[idx] < lookupValue) {
                    if (!indexValue) {
                        index = idx + 1;
                        indexValue = lookupArray[idx];
                    } else if (lookupArray[idx] > indexValue) {
                        index = idx + 1;
                        indexValue = lookupArray[idx];
                    }
                }
            } else if (matchType === 0) {
                if (typeof lookupValue === 'string') {
                    // '?' is mapped to the regex '.'
                    // '*' is mapped to the regex '.*'
                    // '~' is mapped to the regex '\?'
                    if (idx === 0) {
                        lookupValue = "^" + lookupValue.replace(/\?/g, '.').replace(/\*/g, '.*').replace(/~/g, '\\?') + "$";
                    }
                    if (typeof lookupArray[idx] !== "undefined") {
                        if (String(lookupArray[idx]).toLowerCase().match(String(lookupValue).toLowerCase())) {
                            return idx + 1;
                        }
                    }
                } else {
                    if (typeof lookupArray[idx] !== "undefined" && lookupArray[idx] !== null && lookupArray[idx].valueOf() === lookupValue) {
                        return idx + 1;
                    }
                }
            } else if (matchType === -1) {
                if (lookupArray[idx] === lookupValue) {
                    return idx + 1;
                } else if (lookupArray[idx] > lookupValue) {
                    if (!indexValue) {
                        index = idx + 1;
                        indexValue = lookupArray[idx];
                    } else if (lookupArray[idx] < indexValue) {
                        index = idx + 1;
                        indexValue = lookupArray[idx];
                    }
                }
            }
        }
        
        return index ? index : error.na;
    };
    
    fn.OFFSET = function(ref, rows, cols, height, width) {
        var topLeft, bottomRight,
            rowsVal = 0, colsVal = 0;
    
        // handle case when cell object is placed in.
        // reference is the string value (e.g. A1)
        var isCell = fn.ISCELL(ref);
        var reference = isCell ? ref.addr() : ref;
    
        try {
            
            
            if (reference.indexOf(':') > 0) {
                topLeft = workbook.cellInfo(reference.split(':')[0]);
            } else {
                topLeft = workbook.cellInfo(reference);
            }
    
            // clone object to avoid messing with memorized cells
            topLeft = JSON.parse(JSON.stringify(topLeft));
    
            if (fn.ISBLANK(rows) || fn.ISBLANK(cols)) {
                return error.na;
            }
            
            rowsVal = fn.ISCELL(rows) ? rows.valueOf() : rows;
            colsVal = fn.ISCELL(cols) ? cols.valueOf() : cols;
    
            if (fn.ISERROR(rowsVal) || fn.ISERROR(colsVal)) {
                return error.na;
            }
            
            topLeft.rowIndex += rowsVal;
            topLeft.colIndex += colsVal;
    
            bottomRight = JSON.parse(JSON.stringify(topLeft));
            
            if (typeof height !== "undefined" && typeof height === "number") {
                bottomRight.rowIndex += width;
            }
            
            if (typeof height !== "undefined" && typeof width === "number") {
                bottomRight.colIndex += height;
            }
            
            var _s = function(point) { return workbook.toColumn(point.colIndex) + (point.rowIndex+1).toString(); }
            topLeft = _s(topLeft);
            bottomRight =  _s(bottomRight);
            if (topLeft === bottomRight) {
                return ref.workbook.cell(ref.sheetIndex, topLeft);
            } else {
                return ref.workbook.range(ref.sheetIndex, topLeft, bottomRight);
            }
            
        } catch (e) {
            return workbook.errors.value;
        }
    };
    fn.INDEX = function(reference, row_num, column_num) {
        var cell, addr, col, row;
        
        if (fn.ISREF(reference)) {
            
            if (fn.ISRANGE(reference)) {
                cell = workbook.cellInfo(reference.topLeft);
            } else {
                if (!fn.ISCELL(reference)) { return workbook.errors.na; }
                cell = workbook.cellInfo(reference.addr());
            }
            
            column_num = column_num || 1;
            col = cell.colIndex + column_num - 1;
            row = cell.rowIndex + row_num ;
            
            addr = workbook.toColumn(col) + (row);
            return reference.sheet.cell(addr);
            
        } else if (fn.ISARRAY(reference)) {
            
            column_num = column_num || 1;
            return reference[row_num-1][column_num-1];
        }
    }
    fn.ROW = function(ref) {
    
        if (fn.ISTEXT(ref)) {
            return workbook.extractCellInfo(ref).row;
        }
    
        if (fn.ISCELL(ref)) {
            return ref.row;
        }
    
        return error.na;
        
    }    
    fn.ROWS = function(ref) {
        var cols = 0;
        
        if (fn.ISARRAY(ref)) {
    
            return ref.length;
        }
    
        if (fn.ISRANGE(ref)) {
            return ref.bottomRight.rowIndex - ref.topLeft.rowIndex;
        }
    
        return error.na;
        
    }
    fn.CELL = function(info_type, reference) {
    
        if (!fn.ISCELL(reference)) {
            return error.NA;
        }
        
        switch (info_type) {
    
        case "address":
            return reference.addr();
        case "col":
            return reference.colIndex +1;
        case "row":
            return reference.row;
        case "color":
            return error.missing;
        case "contents":
            return error.missing;
        case "format":
            return error.missing;
        case "parentheses":
            return error.missing;
        case "prefix":
            return error.missing;
        case "protect":
            return error.missing;
        case "type":
            return error.missing;
        case "width":
            return error.missing;
        }
    
    };    
    fn.DEPENDENTS = function(cell) {
        return cell.sheet.findDependents(cell).map(function(n) {
            return workbook.sheetName(cell.sheet, n.addr());
        });
    };    
    fn.INFO = function(text_type) {
    };
    fn.ISARRAY = function(arr) {
        if( Object.prototype.toString.call( arr ) === '[object Array]' ) {
            return true;
        } else {
            return false;
        }
    }; 
    fn.ISBLANK = function(value) {
        if (fn.ISCELL(value)) {
            value = value.valueOf();
        }
        
        return typeof value === 'undefined' || value === null;
    };    
    fn.ISBINARY = function (number) {
        return (/^[01]{1,10}$/).test(number);
    };    
    fn.ISCELL = function(ref) {
        return (fn.ISOBJECT(ref) && ref.constructor.name === "cell");
    }    
    fn.ISEMAIL = function(email) {
        var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
        return re.test(email);
    };
    fn.ISERR = function(value) {
        if (typeof value === 'undefined' || value === null) { return false; }
        value = value.valueOf();
        return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
            (typeof value === 'number' && (value !== value || !isFinite(value))); // ensure numbers are not NaN or Infinity
    };    
    fn.ISERROR = function(value) {
        if (fn.ISCELL(value)) { value = value.valueOf(); }
        return fn.ISERR(value) || value === error.na;
    };    
    fn.ISEVEN = function(value) {
        if (fn.ISCELL(value)) { value = value.valueOf(); }
        return (Math.floor(Math.abs(value)) & 1) ? false : true;
    };    
    fn.ISFORMULA = function(ref) {
        return fn.ISCELL(ref) && ref.workbook.cells[ref.sheetIndex][ref.cellIndex].hasOwnProperty('fid');
    };    
    fn.ISFUNCTION = function(fun) {
        return fun && Object.prototype.toString.call(fun) == '[object Function]';
    };    
    fn.ISLOGICAL = function(value) {
        return value === true || value === false;
    };    
    fn.ISNA = function(value) {
        if (fn.ISCELL(value)) { value = value.valueOf(); }
        return value === error.na;
    };    
    fn.ISNONTEXT = function(value) {
        return typeof(value) !== 'string';
    };    
    fn.ISNUMBER = function(value) {
        return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
    };    
    fn.ISODD = function(value) {
        if (fn.ISCELL(value)) { value = value.valueOf(); }
        return (Math.floor(Math.abs(value)) & 1) ? true : false;
    };    
    fn.ISOBJECT = function(value) {
        return (value && typeof value == 'object') || false;
    };   
    fn.ISRANGE = function(ref) {
        return (fn.ISOBJECT(ref) && ref.constructor.name === "range");
    };    
    fn.ISREF = function(ref) {
        return (fn.ISOBJECT(ref) && (ref.constructor.name === "cell" || ref.constructor.name === "range"));
    };    
    fn.ISTEXT = function(value) {
        return typeof(value) === 'string';
    };
    fn.N = function(value) {
        if (fn.ISNUMBER(value)) {
            return value;
        }
        if (value instanceof Date) {
            return value.getTime();
        }
        if (value === true) {
            return 1;
        }
        if (value === false) {
            return 0;
        }
        if (fn.ISERROR(value)) {
            return value;
        }
        return 0;
    };    
    fn.NA = function() {
        return error.na;
    };    
    fn.PRECEDENTS = function(cell) {
    
        if (cell.fid) {
            return cell.workbook.functions[cell.fid].precedents;
        }
    
        return [ ];
    
    };
    fn.SHEET = function(name) {
        return this.workbook.get(name);
    };    
    workbook.fn.SHEETS = function() {
        return Object.keys(this.workbook.sheets).length;
    };    
    workbook.fn.TYPE = function(value) {
        if (workbook.fn.ISLOGICAL(value)) {
            return 4;
        }
        else if (workbook.fn.ISTEXT(value)) {
            return 2;
        }
        else if (workbook.fn.ISNUMBER(value)) {
            return 1;
        }
        else if (workbook.fn.ISERROR(value)) {
            return 16;
        }
        else if (workbook.fn.ISARRAY(value)) {
            return 64;
        }
    };
    fn.NUMBERS = function () {
        var possibleNumbers = fn.flatten(arguments);
    
        var arr = [], n;
    
        for (var i = 0; i < possibleNumbers.length; i++) {
            n = possibleNumbers[i];
            if (fn.ISNUMBER(n)) {
                arr.push(n);
            }
        }
    
        return arr;
    
    };
    fn.UNIQUE = function () {
        var result = [];
        var range = fn.flatten(arguments)
        for (var i = 0; i < range.length; ++i) {
            var hasElement = false;
            var element    = range[i];
    
            // Check if we've already seen this element.
            for (var j = 0; j < result.length; ++j) {
                hasElement = result[j] === element;
                if (hasElement) { break; }
            }
    
            // If we did not find it, add it to the result.
            if (!hasElement) {
                result.push(element);
            }
        }
        return result;
    };
    fn.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
        // Return error if either date is invalid
        var issueDate      = fn.parseDate(fn.DATEVALUE(issue.valueOf()));
        var firstDate      = fn.parseDate(fn.DATEVALUE(first.valueOf()));
        var settlementDate = fn.parseDate(fn.DATEVALUE(settlement.valueOf()));
    
        // Set default values
        par   = par.valueOf()   || 0;
        basis = basis.valueOf() || 0;
        rate = rate.valueOf();
        
        var validDate = fn.validDate;
        
        if (!validDate(issueDate) || !validDate(firstDate) || !validDate(settlementDate)) {
            return error.value;
        }
    
    
        // Return error if either rate or par are lower than or equal to zero
        if (rate <= 0 || par <= 0) {
            return error.num;
        }
    
        // Return error if frequency is neither 1, 2, or 4
        if ([1, 2, 4].indexOf(frequency.valueOf()) === -1) {
            return error.num;
        }
    
        // Return error if basis is neither 0, 1, 2, 3, or 4
        if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
            return error.num;
        }
    
        // Return error if settlement is before or equal to issue
        if (settlementDate <= issueDate) {
            return error.num;
        }
    
    
        // Compute accrued interest
        return par * rate * fn.YEARFRAC(issueDate, settlementDate, basis);
    };
    fn.CUMIPMT = function(rate, periods, value, start, end, type) {
        // Credits: algorithm inspired by Apache OpenOffice
        // Credits: Hannes Stiebitzhofer for the translations of function and variable names
        var utils = workbook.fn;
        
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        value = utils.parseNumber(value);
        if (utils.isAnyError(rate, periods, value)) {
            return error.value;
        }
    
        // Return error if either rate, periods, or value are lower than or equal to zero
        if (rate <= 0 || periods <= 0 || value <= 0) {
            return error.num;
        }
    
        // Return error if start < 1, end < 1, or start > end
        if (start < 1 || end < 1 || start > end) {
            return error.num;
        }
    
        // Return error if type is neither 0 nor 1
        if (type !== 0 && type !== 1) {
            return error.num;
        }
    
        // Compute cumulative interest
        var payment = fn.PMT(rate, periods, value, 0, type);
        var interest = 0;
    
        if (start === 1) {
            if (type === 0) {
                interest = -value;
                start++;
            }
        }
    
        for (var i = start; i <= end; i++) {
            if (type === 1) {
                interest += fn.FV(rate, i - 2, payment, value, 1) - payment;
            } else {
                interest += fn.FV(rate, i - 1, payment, value, 0);
            }
        }
        interest *= rate;
    
        // Return cumulative interest
        return interest;
    };
    fn.PMT = function(rate, periods, present, future, type) {
    
        future = fn.N(future) || 0;
        type = fn.N(type) || 0;
    
        var payment;
        if (rate === 0) {
            payment = (present + future) / periods;
        } else {
            var term = Math.pow(1 + rate, periods);
            if (type === 1) {
                payment = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
            } else {
                payment = future * rate / (term - 1) + present * rate / (1 - 1 / term);
            }
        }
        return -payment;
    };
    fn.FV = function(rate, periods, payment, value, type) {
    
        if (typeof rate === 'undefined') throw Error("rate is undefined");
        if (typeof periods === 'undefined') throw Error("rate is undefined");
        if (typeof payment === 'undefined') throw Error("rate is undefined");
    
        value = value || 0;
        type = type || 0;
    
    
        var fv;
        if (rate === 0) {
            fv = value + payment * periods;
        } else {
            var term = Math.pow(1 + rate, periods);
            if (type === 1) {
                fv = value * term + payment * (1 + rate) * (term - 1) / rate;
            } else {
                fv = value * term + payment * (term - 1) / rate;
            }
        }
        return -fv;
    };
      fn.PV = function(rate, periods, payment, future, type) {
    if (typeof rate === 'undefined') throw Error("rate is undefined");
    if (typeof periods === 'undefined') throw Error("rate is undefined");
    if (typeof payment === 'undefined') throw Error("rate is undefined");
        
    future = future || 0;
    type = type || 0;
    
    if (rate === 0) {
        return -payment * periods - future;
    } else {
        return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
    }
      };
    fn.NPV = function(rate) {
        rate = rate * 1;
        var factor = 1,
            sum = 0;
    
        for(var i = 1; i < arguments.length; i++) {
            var factor = factor * (1 + rate);
            sum += arguments[i] / factor;
        }
    
        return sum;
    }
    fn.IPMT = function(rate, per, nper, pv, fv, type) {
        var pmt = fn.PMT(rate, nper, pv, fv, type),
            fv = fn.FV(rate, per - 1, pmt, pv, type),
            result = fv * rate;
    
        // account for payments at beginning of period versus end.
        if (type) {
            result /= (1 + rate);
        }
    
        return result;
    }
    fn.NPER = function(rate, pmt, pv, fv, type) { 
        var log,
            result;
        rate = parseFloat(rate || 0);
        pmt = parseFloat(pmt || 0);
        pv = parseFloat(pv || 0);
        fv = (fv || 0);
        type = (type || 0);
    
        log = function(prim) {
            if (isNaN(prim)) {
                return Math.log(0);
            }
            var num = Math.log(prim);
            return num;
        }
    
        if (rate == 0.0) {
            result = (-(pv + fv)/pmt);
        } else if (type > 0.0) {
            result = (log(-(rate*fv-pmt*(1.0+rate))/(rate*pv+pmt*(1.0+rate)))/(log(1.0+rate)));
        } else {
            result = (log(-(rate*fv-pmt)/(rate*pv+pmt))/(log(1.0+rate)));
        }
    
        if (isNaN(result)) {
            result = 0;
        }
    
        return result;
    }
    fn.ABS = function(v) { return Math.abs(v); }
    fn.ACOS = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.acos(number);
    };
    fn.ACOSH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.log(number + Math.sqrt(number * number - 1));
    };    
    fn.ACOT = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.atan(1 / number);
    };
            
    fn.ACOTH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return 0.5 * Math.log((number + 1) / (number - 1));
    };
    
    fn.ADD = function(a, b) {
    
        // force conversion to number
        a = +a;
        b = +b;
    
        // check for NaN
        if (a !== a || b !== b) {
            return error.value;
        }
        
        return a + b;
    }    
    fn.ASIN = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.asin(number);
    };
    fn.ASINH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.log(number + Math.sqrt(number * number + 1));
    };    
    fn.ATAN = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.atan(number);
    };        
    fn.ATAN2 = function(number_x, number_y) {
    
        if (!fn.ISNUMBER(number_x)) {
            return error.value;
        }
    
        if (!fn.ISNUMBER(number_y)) {
            return error.value;
        }
        
        
        return Math.atan2(number_x, number_y);
    };
    fn.ATANH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.log((1 + number) / (1 - number)) / 2;
    };            
    fn.BASE = function(number, radix, min_length) {
      min_length = min_length || 0;
    
      number = fn.parseNumber(number);
      radix = fn.parseNumber(radix);
      min_length = fn.parseNumber(min_length);
      if (fn.isAnyError(number, radix, min_length)) {
        return error.value;
      }
      min_length = (min_length === undefined) ? 0 : min_length;
      var result = number.toString(radix);
      return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
    
    }
    fn.CEILING = function(number, significance, mode) {
        var utils = workbook.fn;
        significance = (significance === undefined) ? 1 : Math.abs(significance);
        mode = mode || 0;
    
        number = utils.parseNumber(number);
        significance = utils.parseNumber(significance);
        mode = utils.parseNumber(mode);
        if (utils.isAnyError(number, significance, mode)) {
            return error.value;
        }
        if (significance === 0) {
            return 0;
        }
        var precision = -Math.floor(Math.log(significance) / Math.log(10));
        if (number >= 0) {
            return fn.ROUND(Math.ceil(number / significance) * significance, precision);
        } else {
            if (mode === 0) {
                return -fn.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
            } else {
                return -fn.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
            }
        }
    };
    
    fn.COMBIN = function(number, number_chosen) {
        var utils = workbook.fn;
        number = utils.parseNumber(number);
        number_chosen = utils.parseNumber(number_chosen);
        if (utils.isAnyError(number, number_chosen)) {
            return error.value;
        }
        return fn.FACT(number) / (fn.FACT(number_chosen) * fn.FACT(number - number_chosen));
    };
    
    fn.COS = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.cos(number);
    };        
    fn.COSH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return (Math.exp(number) + Math.exp(-number)) / 2;
    };        
    fn.COT = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return 1 / Math.tan(number);
    };        
    fn.COTH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        var e2 = Math.exp(2 * number);
        return (e2 + 1) / (e2 - 1);
    
    };        
    fn.CSC = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return 1 / Math.sin(number);
    };        
    fn.CSCH = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return 2 / (Math.exp(number) - Math.exp(-number));
    };        
    fn.DECIMAL = function(number, radix) {
        if (arguments.length < 1) {
            return error.value;
        }
    
        return parseInt(number, radix);
    };
    fn.DEGREES = function(number) {
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return number * 180 / Math.PI;
    };
    fn.DIVIDE = function(a, b) {
    
        // force conversion to number
        a = +a;
        b = +b;
    
        // check for NaN
        if (a !== a || b !== b) {
            return error.value;
        }
        
        return a / b;
    }    
    fn.EVEN = function(number) {
        number = fn.parseNumber(number);
        if (number instanceof Error) {
            return number;
        }
        return fn.CEILING(number, -2, -1);
    };
    fn.EQ = function(a, b) {
        
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        // Unlike the host language the string comparisions are 
        if (typeof a === "string" && typeof b === "string") {
            return a.toLowerCase() === b.toLowerCase()
        } else {
            return a === b;
        }
    
    }    
    fn.EXP = function(num) {
        return Math.pow(Math.E, num);
    }
    var MEMOIZED_FACT = [];
    fn.FACT = function(number) {
        number = fn.parseNumber(number);
        if (number instanceof Error) {
            return number;
        }
        var n = Math.floor(number);
        if (n === 0 || n === 1) {
            return 1;
        } else if (MEMOIZED_FACT[n] > 0) {
            return MEMOIZED_FACT[n];
        } else {
            MEMOIZED_FACT[n] = fn.FACT(n - 1) * n;
            return MEMOIZED_FACT[n];
        }
    };
    fn.FACTDOUBLE = function(number) {
      number = fn.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var n = Math.floor(number);
      if (n <= 0) {
        return 1;
      } else {
        return n * fn.FACTDOUBLE(n - 2);
      }
    };
      fn.FLOOR = function (value, significance) {
    significance = significance || 1;
    
    if (
        (value < 0 && significance > 0 )
      || (value > 0 && significance < 0 )
    ) {
        var result = new Number(0);
        return result;
    }
    if (value >= 0) {
        return Math.floor(value / significance) * significance;
    } else {
        return Math.ceil(value / significance) * significance;
    }
      }
     
    // adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
    fn.GCD = function() {
        var utils = workbook.fn;
        var range = utils.parseNumberArray(utils.flatten(arguments));
        if (range instanceof Error) {
            return range;
        }
        var n = range.length;
        var r0 = range[0];
        var x = r0 < 0 ? -r0 : r0;
        for (var i = 1; i < n; i++) {
            var ri = range[i];
            var y = ri < 0 ? -ri : ri;
            while (x && y) {
                if (x > y) {
                    x %= y;
                } else {
                    y %= x;
                }
            }
            x += y;
        }
        return x;
    };
    fn.GT = function(a, b) {
    
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        return a > b;
    
    }    
    fn.GTE = function(a, b) {
    
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        return a >= b;
    
    }    
    fn.LCM = function() {
        // Credits: Jonas Raoni Soares Silva
        var utils = workbook.fn;
        var o = utils.parseNumberArray(utils.flatten(arguments));
        if (o instanceof Error) {
            return o;
        }
        for (var i, j, n, d, r = 1;
             (n = o.pop()) !== undefined;) {
            while (n > 1) {
                if (n % 2) {
                    for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
                        //empty
                    }
                    d = (i <= j) ? i : n;
                } else {
                    d = 2;
                }
                for (n /= d, r *= d, i = o.length; i;
                     (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
                    //empty
                }
            }
        }
        return r;
    };
    
    fn.LN = function(number) {
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.log(number);
    };        
    fn.LOG = function(number, base) {
    
        base = base || 10;
    
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        if (!fn.ISNUMBER(base)) {
            return error.value;
        }
    
        return Math.log(number) / Math.log(base);
    
    };        
    fn.LOG10 = function(number) {
        if (!fn.ISNUMBER(number)) {
            return error.value;
        }
    
        return Math.log(number) / Math.log(10);
    }
    fn.LT = function(a, b) {
    
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        return a < b;
    
    }
    fn.LTE = function(a, b) {
    
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        return a <= b;
    
    }    
    fn.INT = function(num) {
        return Math.floor(num);
    }
    fn.MINUS = function(a, b) {
    
        // force conversion to number
        a = +a;
        b = +b;
    
        // check for NaN
        if (a !== a || b !== b) {
            return error.value;
        }
        
        return a - b;
    }    
    fn.MOD = function(a, b) {
        return a % b;
    }
    fn.MULTIPLY = function(a, b) {
    
        // force conversion to number
        a = +a;
        b = +b;
    
        // check for NaN
        if (a !== a || b !== b) {
            return error.value;
        }
        
        return a * b;
    }    
    fn.NE = function(a, b) {
    
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        return a !== b;
    
    }
    fn.PI = function() { return Math.PI };
    fn.POW = fn.POWER = function(val, nth) {
        return Math.pow(val, nth);
    }
    fn.PRODUCT = function() {
        var range = fn.flatten(arguments);
        var result = range[0];
        
        for (var i = 1; i < range.length; i++) {
            result *= range[i];
        }
    
        return result;
    }
    fn.QUOTIENT = function(a, b) {
        var q = Math.floor( a / b );
        if (q !== q) {
            return error.value;
        }
        return q;
    }
    fn.RADIANS = function(number) {
      number = fn.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return number * Math.PI / 180;
    };
    fn.RAND = function() {
      return Math.random();
    };    
    fn.RANDBETWEEN = function(bottom, top) {
      bottom = fn.parseNumber(bottom);
      top = fn.parseNumber(top);
      if (fn.isAnyError(bottom, top)) {
        return error.value;
      }
      // Creative Commons Attribution 3.0 License
      // Copyright (c) 2012 eqcode
      return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
    };
    fn.ROUND = function(number, precision) {
        return +number.toFixed(precision);
    }
    fn.ROUNDUP = function(number, precision) {
        var factors = [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000];
        var factor = factors[precision];
        if (number > 0) {
            return Math.ceil(number * factor) / factor;
        } else {
            return Math.floor(number * factor) / factor;
        }
    }
    
    fn.SUM = function () {
        var numbers = fn.flatten(arguments);
        var result = 0;
        for (var i = 0; i < numbers.length; i++) {
            if (numbers[i] instanceof Array) {
                for (var j = 0; j < numbers[i].length; j++) {
                    result += (fn.ISNUMBER(numbers[i][j])) ? numbers[i][j] : fn.ISCELL(numbers[i][j]) ? numbers[i][j].valueOf() : 0;
                }
            } else {
                result += (fn.ISNUMBER(numbers[i])) ? numbers[i] : fn.ISCELL(numbers[i]) ? numbers[i].valueOf() : 0;
            }
        }
    
        return result;
    };
    fn.SUMIF = function (range, criteria) {
        range = fn.flatten(range);
        var result = 0;
        for (var i = 0; i < range.length; i++) {
            result += (eval(range[i] + criteria)) ? range[i] : 0;
        }
        return result;
    }
    fn.AVERAGE = function () {
        var set = fn.flatten.apply(this, arguments);
        return fn.SUM(set) / set.length;
    }
    fn.COUNT = function () {
        var count = 0,
            v = arguments,
            i = v.length - 1;
    
        if (i < 0) {
            return count;
        }
    
        do {
            if (v[i] !== null) {
                count++;
            }
        } while (i--);
    
        return count;
    }
    fn.COUNTIF = function(range, criteria) {
        range = fn.flatten(range);
        if (!/[<>=!]/.test(criteria)) {
            criteria = '=="' + criteria + '"';
        }
        var matches = 0;
        for (var i = 0; i < range.length; i++) {
            if (typeof range[i] !== 'string') {
    
                if (fn.ISERROR(range[i])) { continue; }
                if (eval(range[i] + criteria)) {
                    matches++;
                }
            } else {
                if (eval('"' + range[i] + '"' + criteria)) {
                    matches++;
                }
            }
        }
        return matches;
    };
    
    fn.MIN = function () {
    
        // flatten the array
        var range = fn.flatten(arguments);
        var min = null;
        var x;
    
        for (var i = 0; i < range.length; i++) {
            x = range[i];
            if (typeof x !== 'number' || isNaN(x)) { continue; }
            if (min === null) {
                min = Number(x); 
            }else if (x < min) {
                min = Number(x);
            }
        }
    
        return min;
    };
    fn.MAX = function () {
    
        // flatten the array
        var range = fn.flatten(arguments);
        var max = null;
        var x;
    
        for (var i = 0; i < range.length; i++) {
            x = range[i];
            if (typeof x !== 'number' || isNaN(x)) { continue; }
            if (max === null) {
                max = Number(x); 
            }else if (x > max) {
                max = Number(x);
            }
        }
    
        return max;
    };
    fn.SLOPE = function(data_y, data_x) {
    /*
        data_y = utils.parseNumberArray(utils.flatten(data_y));
        data_x = utils.parseNumberArray(utils.flatten(data_x));
    
        if (utils.anyIsError(data_y, data_x)) {
            return error.value;
        }
        var xmean = jStat.mean(data_x);
        var ymean = jStat.mean(data_y);
        
        var n = data_x.length;
    
        var num = 0;
        var den = 0;
    
        for (var i = 0; i < n; i++) {
            num += (data_x[i] - xmean) * (data_y[i] - ymean);
            den += Math.pow(data_x[i] - xmean, 2);
        }
    
        return num / den;
    */
    };
    fn.CHAR = function(number) {
        number = fn.parseNumber(number);
        if (number instanceof Error) {
            return number;
        }
        return String.fromCharCode(number);
    };
    fn.CLEAN = function(text) {
        var out = "";
    
        for (var i = 0; i < text.length; i++) {
            if (text.charCodeAt(i) > 31) {
                out += text[i];
            }
        }
    
        return out;
    }
    fn.CODE = function(text) {
        text = text || '';
        return text.charCodeAt(0);
    };
    fn.CONCAT = fn.CONCATENATE = function() {
        var args = fn.flatten(arguments);
    
        for (var i = 0; i < args.length; i++) {
            if (args[i] === true) { args[i] = 'TRUE'; }
            else if (args[i] === false) { args[i] = 'FALSE'; }
            else { args[i] = args[i] ? args[i].valueOf() : '' }
        }
    
        return args.join('');
    };
    fn.DOLLAR = function(num) {
        return fn.TEXT(num, '$#,##0.00_);($#,##0.00)');
    }
    fn.EXACT = function(a, b) {
        
        if (fn.ISCELL(a)) {
            a = a.valueOf();
        }
    
        if (fn.ISCELL(b)) {
            b = b.valueOf();
        }
    
        if (typeof a !== "string" || typeof b !== "string") {
            return error.na;
        }
    
        return a === b;
    }
    fn.FIND = function (find_text, within_text, position) {
        if (!within_text) { return null; }
        position = (typeof position === 'undefined') ? 1 : position;
        position = within_text.indexOf(find_text, position - 1) + 1;
        return position === 0 ? workbook.errors.value : position;
    }
    fn.FIXED = function(num, decimals, commas) {
        if (commas) { return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
        return num.toFixed(decimals);
    }
    fn.LEFT = function(text, number) {
        number = (number === undefined) ? 1 : number;
        number = fn.parseNumber(number);
        if (number instanceof Error || typeof text !== 'string') {
            return error.value;
        }
        return text ? text.substring(0, number) : null;
    };
      LEN = function(text) {
    if (arguments.length === 0) {
        return error.error;
    }
    
    if (typeof text === 'string') {
        return text ? text.length : 0;
    }
    
    if (text.length) {
        return text.length;
    }
    
    return error.value;
      };
    fn.LOWER = function(text) {
        if (typeof text === 'undefined' || text === null) return "";
        return text.toLowerCase();
    }     
    fn.JOIN = function (array, separator) {
        return array.join(separator);
    };
    fn.MID = function(text, start, number) {
        start = fn.parseNumber(start);
        number = fn.parseNumber(number);
        if (fn.isAnyError(start, number) || typeof text !== 'string') {
            return number;
        }
        return text.substring(start - 1, number+1);
    };
    fn.PROPER = function(text) {
        if (text === undefined || text.length === 0) {
            return error.value;
        }
        if (text === true) {
            text = 'TRUE';
        }
        if (text === false) {
            text = 'FALSE';
        }
        if (isNaN(text) && typeof text === 'number') {
            return error.value;
        }
        if (typeof text === 'number') {
            text = '' + text;
        }
    
        return text.replace(/\w\S*/g, function(txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    };
    fn.REPLACE = function(text, position, length, new_text) {
        position = fn.parseNumber(position);
        length = fn.parseNumber(length);
        if (fn.isAnyError(position, length) ||
            typeof text !== 'string' ||
            typeof new_text !== 'string') {
            return error.value;
        }
        return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
    };
    fn.REPT = function(t, n) {
        var r = "";
        for (var i = 0; i < n; i++) {
            r += t;
        }
        return r;
    }
    fn.RIGHT = function(text, number) {
        number = (number === undefined) ? 1 : number;
        number = fn.parseNumber(number);
        if (number instanceof Error) {
            return number;
        }
        return text ? text.substring(text.length - number) : null;
    };
    fn.SEARCH = function (find_text, within_text, position) {
        if (!within_text) { return null; }
        position = (typeof position === 'undefined') ? 1 : position;
    
        // The SEARCH function translated the find_text into a regex.
        var find_exp = find_text
            .replace(/([^~])\?/g, '$1.')   // convert ? into .
            .replace(/([^~])\*/g, '$1.*')  // convert * into .*
            .replace(/([~])\?/g, '\\?')    // convert ~? into \?
            .replace(/([~])\*/g, '\\*');   // convert ~* into \*
    
        position = new RegExp(find_exp, "i").exec(within_text);
    
        if (position) { return position.index + 1 }
        return workbook.errors.value;
    }
    fn.SPLIT = function (text, separator) {
        return text.split(separator);
    };
    fn.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
        if (!text || !old_text || !new_text) {
            return text;
        } else if (occurrence === undefined) {
            return text.replace(new RegExp(old_text, 'g'), new_text);
        } else {
            var index = 0;
            var i = 0;
            while (text.indexOf(old_text, index) > 0) {
                index = text.indexOf(old_text, index + 1);
                i++;
                if (i === occurrence) {
                    return text.substring(0, index) + new_text + text.substring(index + old_text.length);
                }
            }
        }
    };
    fn.T = function(value) {
        return (typeof value === "string") ? value : '';
    };
    fn.TEXT = function(value, format) {
        return workbook.FormatNumber.formatNumberWithFormat(value, format);
    };
    fn.TRIM = function(text) {
        if (typeof text !== 'string') {
            return error.value;
        }
        return text.replace(/ +/g, ' ').trim();
    };
    fn.UPPER = function(text) {
        if (typeof text === 'undefined' || text === null) return "";
        return text.toUpperCase();
    }     
    fn.VALUE = function(t) {
        return Number.parseFloat(t);
    }         
    
    // Handle compatibility with Node.js
    if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = workbook;
    }

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (typeof define === 'function' && define.amd) {
        define('formula', [], function() {
            return workbook;
        });
    }

    // Web Workers
    if (typeof importScripts === 'function') {
        workbook.onmessage = function (oEvent) {
            
            var req = oEvent.data;
            
            switch(req.command) {
            case "start":
            case "load-workbook":
                workbook.Current = new workbook(req.config);

                postMessage({ req: req, res: "sucess" });
                return;
            case "create-worksheet": 
                var ws = workbook.Current.sheet(req.config);


                ws.on("set", function(addr, newValue, oldValue) {
                    postMessage({
                        command: "set",
                        res: {
                            worksheet: this.name,
                            addr: addr,
                            newValue: newValue,
                            oldValue: oldValue
                        }
                    });
                });

                ws.on("updated", function(addr, newValue, oldValue) {
                    postMessage({
                        command: "updated",
                        res: {
                            worksheet: this.name,
                            addr: addr,
                            newValue: newValue,
                            oldValue: oldValue
                        }
                    });
                });
                
                postMessage({ req: req, res: "sucess" });
                return;
            case "set":
                var result = workbook.Current.get(req.worksheet).set(req.ref, req.value).get(req.ref);
                postMessage({ req: req, res: "sucess" });
                return;
            case "get":
                var result = workbook.Current.get(req.worksheet).get(req.ref);
                if (fn.ISCELL(result)) {
                    result = { addr: result.addr(), worksheet: result.worksheet.name, value: result.valueOf() }
                }
                postMessage({ req: req, res: result });
                return;
            case "run":
                var result = workbook.Current.get(req.worksheet).run(req.fn);
                if (fn.ISCELL(result)) {
                    result = { addr: result.addr(), worksheet: result.worksheet.name, value: result.valueOf() }
                }
                postMessage({ req: req, res: result });         
                return;
            case "name":
                var result = workbook.Current.get(req.worksheet).nameRange(req.name, req.ref);
                postMessage({ req: req, res: result });
                return;
            }
            
            postMessage("unknown request");
            
        };

        onmessage = workbook.onmessage;
    }


    return workbook;

})(this);
